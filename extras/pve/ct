#!/usr/bin/env bash

# shellcheck disable=SC1091

set -euo pipefail -o errtrace

export DOT_DIR=${DOT_DIR:-"$HOME/.ilm"}
source "$DOT_DIR/share/utils"
source "$(dirname "$0")/utils"

readonly DEFAULT_PASSWORD="program"

check_prerequisites() {
  if ! has_cmd pct; then
    echo "‚ùå  Required command 'pct' is not available."
    echo "This script must be run on a Proxmox host."
    exit 1
  fi
}

ct_all_install() {
  local storage=""
  local password="$DEFAULT_PASSWORD"

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --password)
      password="$2"
      shift 2
      ;;
    *)
      if [[ -z "$storage" ]]; then
        storage="$1"
      fi
      shift
      ;;
    esac
  done

  if [[ -n "$storage" ]]; then
    if ! pvesm status | grep -q "$storage"; then
      fail "Storage '$storage' not found"
      return 1
    fi
  elif pvesm status | grep -q "local-zfs"; then
    storage="local-zfs"
  elif pvesm status | grep -q "local-lvm"; then
    storage="local-lvm"
  else
    fail "No suitable storage found"
    return 1
  fi

  echo "üöÄ Creating containers from all templates..."
  local template_dir="/var/lib/vz/template/cache"
  local ct_id=150

  if ! dir_exists "$template_dir"; then
    fail "Template directory not found: $template_dir"
    return 1
  fi

  for template in "$template_dir"/*; do
    if file_exists "$template"; then
      local template_name
      template_name=$(basename "$template")
      echo "üì¶ Creating LXC from template: $template_name"

      local distro=""
      case "$template_name" in
      ubuntu*) distro="ubuntu" ;;
      archlinux*) distro="archlinux" ;;
      debian*) distro="debian" ;;
      fedora*) distro="fedora" ;;
      almalinux*) distro="almalinux" ;;
      alpine*) distro="alpine" ;;
      centos*) distro="centos" ;;
      rockylinux*) distro="rockylinux" ;;
      opensuse*) distro="opensuse" ;;
      *)
        distro=$(echo "$template_name" | cut -d'-' -f1)
        echo "‚ö†Ô∏è Warning: Unknown distro '$distro', using as-is"
        ;;
      esac

      if pct status "$ct_id" &>/dev/null; then
        echo "‚è≠Ô∏è Container ID $ct_id already exists, skipping..."
        ((ct_id++))
        continue
      fi

      if "$(dirname "$0")/ct-create" --distro "$distro" --id "$ct_id" \
        --storage "$storage" --password "$password"; then
        echo "‚úÖ Successfully created container with ID $ct_id"
      else
        echo "‚ùå Failed to create container with ID $ct_id from template $template_name"
      fi
      ((ct_id++))
    fi
  done

  echo "üéâ Creating containers from all templates done!"
}

ct_templates_download() {
  echo "üì• Installing container templates..."

  if ! has_cmd pveam; then
    echo "‚ùå pveam command not found. Is Proxmox VE installed?"
    return 1
  fi

  local templates=(
    "ubuntu.*standard"
    "debian.*standard"
    "fedora.*default"
  )

  local available_templates
  if ! available_templates=$(pveam available 2>&1); then
    echo "‚ùå Failed to retrieve available templates: $available_templates"
    return 1
  fi

  local downloaded=0
  local failed=0

  for pattern in "${templates[@]}"; do
    local template
    echo "üîç Looking for template matching pattern: $pattern"

    template=$(echo "$available_templates" |
      awk '{print $2}' |
      grep -E "${pattern}" |
      sort -V |
      tail -n 1)
    echo "üìã Found template: $template"

    if [[ -n "$template" ]]; then
      if pveam list local 2>/dev/null | grep -q "$template"; then
        echo "‚úÖ Template already exists: $template"
        ((++downloaded))
      elif pveam download local "$template"; then
        echo "‚úÖ Downloaded template: $template"
        ((++downloaded))
      else
        echo "‚ùå Failed to download $template"
        ((++failed))
      fi
    else
      echo "‚ùå No template found for pattern: $pattern"
      ((++failed))
    fi
  done

  echo "üéâ Container templates installation done: $downloaded succeeded, $failed failed"
  return 0
}

usage() {
  cat <<EOF
Usage: $0 <command> [ct-id...]

Manage LXC containers on Proxmox. These are lightweight containers using the pct command.

COMMANDS:
    list                      List all containers
    create  ARGS              Create a new container (same arguments as ct-create)
    create-all <storage>      Create containers from all available templates
    create-all --password <password> <storage>  Create containers with password
    start <ct-id...>          Start one or more containers
    stop <ct-id...>           Stop one or more containers
    restart <ct-id...>        Restart one or more containers
    shutdown <ct-id...>       Gracefully stop one or more containers
    delete <ct-id...>         Delete one or more containers completely
    console <ct-id>           Connect to container console
    exec <ct-id> CMD          Execute command in container
    ssh <ct-id> [user]        SSH into container (requires SSH setup)
    show-ip <ct-id>           Show container IP address
    info <ct-id>              Show container status and information
    status <ct-id>            Show container status
    enter <ct-id>             Enter container namespace
    snapshot <ct-id> [name]   Create snapshot of container
    rollback <ct-id> <name>  Rollback to snapshot
    templates                 List available templates
    templates sync            Sync/download common container templates
    help                      Show this help message

EXAMPLES:
    $0 list                    # List all containers
    $0 show-ip 100             # Show IP address of container 100
    $0 status 100              # Show status of container 100
    $0 start 100               # Start container 100
    $0 start 100 101 102       # Start containers 100, 101, and 102
    $0 stop 100                # Stop container 100
    $0 stop 100 101 102        # Stop containers 100, 101, and 102
    $0 delete 100              # Delete container 100
    $0 delete 100 101 102      # Delete containers 100, 101, and 102
    $0 console 100             # Connect to container console
    $0 exec 100 -- apt update  # Run command in container
    $0 ssh 100                 # SSH into container 100 as root
    $0 ssh 100 username        # SSH into container 100 as username
    $0 templates sync          # Sync/download common templates
    $0 create-all              # Create containers from all available templates (local-lvm/local-zfs)
    $0 create-all local-zfs    # Create containers using specific storage
    $0 create-all --password mypass local-zfs  # Create containers with password
    $0 create --template ubuntu-22.04-standard_22.04-1_amd64.tar.zst --id 100
    $0 create --distro ubuntu --id 100 --password mysecretpassword
EOF
}

list_ct() {
  pct list
}

status_ct() {
  check_container "$1"
  pct status "$1"
}

info_ct() {
  check_container "$1"
  pct config "$1"
}

start_ct() {
  for ct_id in "$@"; do
    check_container "$ct_id"
    echo "üöÄ Starting container $ct_id..."
    pct start "$ct_id"
  done
}

stop_ct() {
  for ct_id in "$@"; do
    check_container "$ct_id"
    echo "‚èπÔ∏è Stopping container $ct_id..."
    pct stop "$ct_id"
  done
}

shutdown_ct() {
  for ct_id in "$@"; do
    check_container "$ct_id"
    echo "üîÑ Shutting down container $ct_id..."
    pct shutdown "$ct_id"
  done
}

restart_ct() {
  for ct_id in "$@"; do
    check_container "$ct_id"
    echo "üîÑ Restarting container $ct_id..."
    pct reboot "$ct_id"
  done
}

delete_ct() {
  for ct_id in "$@"; do
    check_container "$ct_id"

    # Stop container if running
    if pct status "$ct_id" | grep -q "status: running"; then
      echo "‚èπÔ∏è Stopping container $ct_id..."
      pct stop "$ct_id"
    fi

    echo "üóëÔ∏è Deleting container $ct_id..."
    pct destroy "$ct_id"
  done
}

console_ct() {
  check_container "$1"
  pct console "$1"
}

exec_ct() {
  local ctid="$1"
  shift
  check_container "$ctid"
  pct exec "$ctid" -- "$@"
}

enter_ct() {
  check_container "$1"
  pct enter "$1"
}

show_ip_ct() {
  check_container "$1"

  local ip=""

  # Method 1: Try to get from network config
  if pct status "$1" | grep -q "status: running"; then
    ip=$(pct exec "$1" -- hostname -I 2>/dev/null | awk '{print $1}' || true)
  fi

  # Method 2: Try to get from Proxmox network info
  if [[ -z "$ip" ]]; then
    ip=$(pct config "$1" | grep -E "ip[0-9]*=" | head -n1 | cut -d'=' -f2 | cut -d',' -f1 | tr -d '"' || true)
  fi

  if [[ -n "$ip" && "$ip" != "dhcp" ]]; then
    echo "üåê Container $1 IP: $ip"
  else
    echo "‚ùå Could not determine IP for container $1"
    echo "üí° Container may not be running or may be using DHCP"
  fi
}

ssh_ct() {
  local ctid="$1"
  local username="${2:-root}" # Default to root if no username provided
  check_container "$ctid"

  local ip
  ip=$(pct exec "$ctid" -- hostname -I 2>/dev/null | awk '{print $1}' || true)

  if [[ -z "$ip" ]]; then
    echo "‚ùå Error: could not determine IP for container '$ctid'"
    echo "üí° - Ensure the container is running"
    echo "üí° - Ensure SSH server is installed in the container"
    echo "üí° - Try: $0 start $ctid; then wait a few seconds."
    exit 1
  fi

  echo "üîê Connecting: ssh $username@$ip"
  exec ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$username@$ip"
}

snapshot_ct() {
  local ctid="$1"
  local snapname="${2:-snap-$(date +%Y%m%d-%H%M%S)}"

  check_container "$ctid"
  echo "üì∏ Creating snapshot '$snapname' for container $ctid..."
  pct snapshot "$ctid" "$snapname"
}

rollback_ct() {
  local ctid="$1"
  local snapname="$2"

  check_container "$ctid"
  echo "‚è™ Rolling back container $ctid to snapshot '$snapname'..."
  pct rollback "$ctid" "$snapname"
}

resolve_ct_id() {
  local id="$1"
  if [[ -n "$id" ]]; then
    printf '%s\n' "$id"
    return 0
  fi

  local containers selected rc
  if ! containers=$(pct list 2>/dev/null | awk 'NR>1 && $0 !~ /^[-[:space:]]*$/ {print $1}'); then
    echo "‚ùå Error: failed to list containers" >&2
    return 1
  fi

  if [[ -z "$containers" ]]; then
    echo "‚ùå Error: no containers found" >&2
    return 1
  fi

  selected=$(printf '%s\n' "$containers" | select-one 'Container > ')
  rc=$?
  if [[ $rc -ne 0 || -z "$selected" ]]; then
    if [[ $rc -eq 127 ]]; then
      echo "‚ùå Error: fzf is not installed or not in PATH" >&2
    else
      echo "‚èπÔ∏è Cancelled" >&2
    fi
    return 1
  fi

  printf '%s\n' "$selected"
}

resolve_multiple_ct_ids() {
  local ids=("$@")
  local resolved_ids=()

  # If no IDs provided, use fzf to select containers
  if [[ ${#ids[@]} -eq 0 ]]; then
    local containers selected rc
    if ! containers=$(pct list 2>/dev/null | awk 'NR>1 && $0 !~ /^[-[:space:]]*$/ {print $1}'); then
      echo "‚ùå Error: failed to list containers" >&2
      return 1
    fi

    if [[ -z "$containers" ]]; then
      echo "‚ùå Error: no containers found" >&2
      return 1
    fi

    # Convert containers string to array for select-multi
    readarray -t container_array <<<"$containers"

    # Use select-multi function for multi-selection
    selected=$(select-multi 'Select containers (TAB to multi-select) > ' "${container_array[@]}")
    rc=$?
    if [[ $rc -ne 0 || -z "$selected" ]]; then
      if [[ $rc -eq 127 ]]; then
        echo "‚ùå Error: fzf is not installed or not in PATH" >&2
      else
        echo "‚èπÔ∏è Cancelled" >&2
      fi
      return 1
    fi

    # Convert selected to array
    readarray -t resolved_ids <<<"$selected"
  else
    # Validate each provided ID
    for id in "${ids[@]}"; do
      if ! container_exists "$id"; then
        echo "‚ùå Error: Container '$id' does not exist" >&2
        return 1
      fi
      resolved_ids+=("$id")
    done
  fi

  # Output the resolved IDs
  printf '%s\n' "${resolved_ids[@]}"
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  check_prerequisites

  local command ct_id
  command="$1"
  ct_id="${2:-}"
  shift

  case "$command" in
  list | ls)
    list_ct
    ;;
  status)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    status_ct "$target"
    ;;
  info)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    info_ct "$target"
    ;;
  create | new)
    # Forward to ct-create script
    "$(dirname "$0")/ct-create" "$@"
    ;;
  create-all)
    ct_all_install "$@"
    ;;
  start | boot)
    {
      readarray -t targets < <(resolve_multiple_ct_ids "$@")
    } || exit 1
    start_ct "${targets[@]}"
    ;;
  stop)
    {
      readarray -t targets < <(resolve_multiple_ct_ids "$@")
    } || exit 1
    stop_ct "${targets[@]}"
    ;;
  shutdown)
    {
      readarray -t targets < <(resolve_multiple_ct_ids "$@")
    } || exit 1
    shutdown_ct "${targets[@]}"
    ;;
  restart | reboot)
    {
      readarray -t targets < <(resolve_multiple_ct_ids "$@")
    } || exit 1
    restart_ct "${targets[@]}"
    ;;
  delete | rm)
    {
      readarray -t targets < <(resolve_multiple_ct_ids "$@")
    } || exit 1
    delete_ct "${targets[@]}"
    ;;
  console)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    console_ct "$target"
    ;;
  exec)
    if [[ -z "$ct_id" ]]; then
      echo "‚ùå Error: Container ID required for exec command"
      echo "üí° Usage: $0 exec <ct-id> -- <command>"
      exit 1
    fi
    check_container "$ct_id"
    shift
    exec_ct "$ct_id" "$@"
    ;;
  enter)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    enter_ct "$target"
    ;;
  show-ip)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    show_ip_ct "$target"
    ;;
  ssh)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    ssh_ct "$target" "${3:-}"
    ;;
  snapshot)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    snapshot_ct "$target" "${3:-}"
    ;;
  rollback)
    {
      target=$(resolve_ct_id "$ct_id")
    } || exit 1
    if [[ -z "${3:-}" ]]; then
      echo "‚ùå Error: Snapshot name required for rollback"
      echo "üí° Usage: $0 rollback <ct-id> <snapshot-name>"
      exit 1
    fi
    rollback_ct "$target" "$3"
    ;;
  templates)
    if [[ "$ct_id" == "sync" ]]; then
      ct_templates_download
    else
      pveam available
    fi
    ;;
  --help | -h | help)
    usage
    ;;
  *)
    echo "‚ùå Error: Unknown command: $command"
    usage
    ;;
  esac
}

main "$@"
