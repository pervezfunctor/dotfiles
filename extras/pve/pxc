#!/usr/bin/env bash
set -euo pipefail

# CONFIG --------------------------------------------------------------
# Default configuration
PVE_HOST="https://pve.example.lan:8006"
TOKEN_ID="vmops@pve!vmops-token"
TOKEN_SECRET="YOUR_API_TOKEN_SECRET"
NODE_NAME="" # leave empty to autodetect
SSH_DEFAULT_USER="root"

# Load configuration from environment file if it exists
load_config() {
  local config_file="${PVE_CONFIG_FILE:-$HOME/.pverc}"

  if [[ -f "$config_file" ]]; then
    info "Loading configuration from $config_file"
    # shellcheck disable=SC1090
    source "$config_file"
  fi

  # Also check for environment variables
  PVE_HOST="${PVE_HOST:-$PVE_HOST}"
  TOKEN_ID="${TOKEN_ID:-$TOKEN_ID}"
  TOKEN_SECRET="${TOKEN_SECRET:-$TOKEN_SECRET}"
  NODE_NAME="${NODE_NAME:-$NODE_NAME}"
  SSH_DEFAULT_USER="${SSH_DEFAULT_USER:-$SSH_DEFAULT_USER}"
}

# Load configuration
load_config
# ---------------------------------------------------------------------

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Error handling
error() {
  echo -e "${RED}Error: $1${NC}" >&2
  exit 1
}

warning() {
  echo -e "${YELLOW}Warning: $1${NC}" >&2
}

info() {
  echo -e "${BLUE}Info: $1${NC}"
}

success() {
  echo -e "${GREEN}Success: $1${NC}"
}

# API function with error handling
api() {
  local method="$1"
  local path="$2"
  local data="${3:-}"

  if [[ -z "$PVE_HOST" || -z "$TOKEN_ID" || -z "$TOKEN_SECRET" ]]; then
    error "PVE_HOST, TOKEN_ID, and TOKEN_SECRET must be configured"
  fi

  local curl_cmd=(
    curl -sS -k
    -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}"
  )

  if [[ "$method" == "GET" ]]; then
    "${curl_cmd[@]}" "${PVE_HOST}/api2/json/${path}"
  elif [[ "$method" == "POST" ]]; then
    if [[ -n "$data" ]]; then
      "${curl_cmd[@]}" -X POST -H "Content-Type: application/json" -d "$data" "${PVE_HOST}/api2/json/${path}"
    else
      "${curl_cmd[@]}" -X POST -d "" "${PVE_HOST}/api2/json/${path}"
    fi
  elif [[ "$method" == "DELETE" ]]; then
    "${curl_cmd[@]}" -X DELETE "${PVE_HOST}/api2/json/${path}"
  else
    "${curl_cmd[@]}" -X "$method" "${PVE_HOST}/api2/json/${path}"
  fi
}

# Auto-detect node if not specified
if [[ -z "$NODE_NAME" ]]; then
  NODE_NAME=$(api GET "nodes" | jq -r '.data[0].node' 2>/dev/null || echo "")
  if [[ -z "$NODE_NAME" ]]; then
    error "Could not auto-detect node name. Please set NODE_NAME in the configuration."
  fi
  info "Auto-detected node: $NODE_NAME"
fi

# Validate container ID
validate_ctid() {
  local ctid="$1"
  if ! [[ "$ctid" =~ ^[0-9]+$ ]]; then
    error "Container ID must be a number"
  fi

  # Check if container exists
  local ct_exists
  ct_exists=$(api GET "nodes/${NODE_NAME}/lxc/${ctid}/status/current" 2>/dev/null | jq -r '.data' 2>/dev/null || echo "")
  if [[ -z "$ct_exists" ]]; then
    error "Container with ID $ctid does not exist"
  fi
}

# Format container status
format_ct_status() {
  local ctid="$1"
  local status_data
  status_data=$(api GET "nodes/${NODE_NAME}/lxc/${ctid}/status/current")
  local status
  status=$(echo "$status_data" | jq -r '.data.status')
  local name
  name=$(echo "$status_data" | jq -r '.data.name')
  local cpus
  cpus=$(echo "$status_data" | jq -r '.data.cpus')
  local memory
  memory=$(echo "$status_data" | jq -r '.data.mem // 0')
  local maxmem
  maxmem=$(echo "$status_data" | jq -r '.data.maxmem // 0')

  # Convert memory to MB
  memory=$((memory / 1024 / 1024))
  maxmem=$((maxmem / 1024 / 1024))

  echo "Container ID: $ctid"
  echo "Name: $name"
  echo "Status: $status"
  echo "CPUs: $cpus"
  echo "Memory: ${memory}MB / ${maxmem}MB"
}

# Container operation functions
start_ct() {
  local ctid="$1"
  info "Starting container $ctid..."
  api POST "nodes/${NODE_NAME}/lxc/$ctid/status/start" >/dev/null
  success "Container $ctid start command sent"
}

stop_ct() {
  local ctid="$1"
  info "Stopping container $ctid..."
  api POST "nodes/${NODE_NAME}/lxc/$ctid/status/stop" >/dev/null
  success "Container $ctid stop command sent"
}

restart_ct() {
  local ctid="$1"
  info "Restarting container $ctid..."
  api POST "nodes/${NODE_NAME}/lxc/$ctid/status/restart" >/dev/null
  success "Container $ctid restart command sent"
}

delete_ct() {
  local ctid="$1"
  warning "This will permanently delete container $ctid. Are you sure? (y/N)"
  read -r confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    info "Deleting container $ctid..."
    api DELETE "nodes/${NODE_NAME}/lxc/$ctid" >/dev/null
    success "Container $ctid deleted"
  else
    info "Operation cancelled for container $ctid"
  fi
}

# Handle multi-container operations
handle_multi() {
  local cmd="$1"
  shift

  local -a ctids=("$@")

  if [[ ${#ctids[@]} -eq 0 ]]; then
    # Get all containers if none specified
    local all_cts
    all_cts=$(api GET "nodes/${NODE_NAME}/lxc" | jq -r '.data[].vmid' 2>/dev/null || true)

    if [[ -z "$all_cts" ]]; then
      error "No containers found. Please create a container first."
    fi

    # Simple selection interface
    echo "Available containers:"
    echo "$all_cts" | nl
    echo ""
    read -r -p "Enter container numbers to $cmd (space-separated, or 'all' for all containers): " selection

    if [[ "$selection" == "all" ]]; then
      readarray -t ctids <<<"$all_cts"
    else
      local -a selected_nums
      read -ra selected_nums <<<"$selection"
      ctids=()
      for num in "${selected_nums[@]}"; do
        local ctid
        ctid=$(echo "$all_cts" | sed -n "${num}p")
        if [[ -n "$ctid" ]]; then
          ctids+=("$ctid")
        fi
      done
    fi

    if [[ ${#ctids[@]} -eq 0 ]]; then
      error "No containers selected. Quitting."
    fi

    echo "Selected containers: ${ctids[*]}"
  fi

  for ctid in "${ctids[@]}"; do
    validate_ctid "$ctid"
    case "$cmd" in
    start)
      start_ct "$ctid"
      ;;
    stop)
      stop_ct "$ctid"
      ;;
    restart)
      restart_ct "$ctid"
      ;;
    rm | delete)
      delete_ct "$ctid"
      ;;
    esac
    echo ""
  done
}

# Usage function
usage() {
  echo "Usage: pxc <command> [args]"
  echo ""
  echo "Container Lifecycle Management:"
  echo "  list                    List all containers"
  echo "  status <ctid>           Show container status and info"
  echo "  start [ctid...]         Start container(s) - if no container IDs provided, select from list"
  echo "  stop [ctid...]          Stop container(s) - if no container IDs provided, select from list"
  echo "  restart [ctid...]       Restart container(s) - if no container IDs provided, select from list"
  echo "  delete [ctid...]        Delete container(s) - if no container IDs provided, select from list"
  echo ""
  echo "Container Interaction:"
  echo "  console <ctid>          Connect to container console"
  echo "  ip <ctid>               Get container IP address"
  echo "  ssh <ctid> [username]   Connect to container via SSH"
  echo ""
  echo "Container Information:"
  echo "  info <ctid>             Show detailed container information"
  echo "  config <ctid>           Show container configuration"
  echo ""
  echo "Utility Commands:"
  echo "  node-list               List all Proxmox nodes"
  echo "  version                 Show PVE version info"
  echo ""
  echo "Examples:"
  echo "  pxc list"
  echo "  pxc start 100"
  echo "  pxc start 100 101 102    # Start multiple containers"
  echo "  pxc stop                 # Select containers to stop from menu"
  echo "  pxc ssh 100 admin"
  echo "  pxc snapshot-create 100 backup-001"
}

cmd="${1:-}"

case "$cmd" in
ls | list)
  info "Listing all containers on node $NODE_NAME..."
  api GET "nodes/${NODE_NAME}/lxc" |
    jq -r '.data[] | "\(.vmid)\t\(.name // "unnamed")\t\(.status)\t\(.cpus)\t\(.maxmem / 1024 / 1024)MB"' |
    (echo -e "CTID\tName\tStatus\tCPUs\tMemory" && cat) |
    column -t
  ;;

status)
  [[ $# -ne 2 ]] && usage && exit 1
  validate_ctid "$2"
  info "Getting status for container $2..."
  format_ct_status "$2"
  ;;

start)
  handle_multi start "${@:2}"
  ;;

stop)
  handle_multi stop "${@:2}"
  ;;

restart)
  handle_multi restart "${@:2}"
  ;;

rm | delete)
  handle_multi delete "${@:2}"
  ;;

ip)
  [[ $# -ne 2 ]] && usage && exit 1
  validate_ctid "$2"
  info "Getting IP addresses for container $2..."
  api GET "nodes/${NODE_NAME}/lxc/$2/interfaces" |
    jq -r '
            .data[]? as $i |
            ($i.name) as $nic |
            ($i."ip-addresses" // [])[]? |
            "\(.["ip-address"])\t\($nic)"
        ' |
    (echo -e "IP Address\tInterface" && cat) |
    column -t
  ;;

ssh)
  [[ $# -lt 2 ]] && usage && exit 1
  validate_ctid "$2"
  CTID="$2"
  USER="${3:-$SSH_DEFAULT_USER}"

  info "Finding IP address for container $CTID..."
  IP=$(api GET "nodes/${NODE_NAME}/lxc/${CTID}/interfaces" |
    jq -r '
                .data[]."ip-addresses"[]? |
                select(."ip-address" | test("^192|10|172")) |
                ."ip-address"' | head -n1)

  if [[ -z "$IP" ]]; then
    error "No IP address found for container $CTID"
  fi

  info "Connecting to $USER@$IP..."
  exec ssh "$USER@$IP"
  ;;

console)
  [[ $# -ne 2 ]] && usage && exit 1
  validate_ctid "$2"
  info "Opening console for container $2..."
  api POST "nodes/${NODE_NAME}/lxc/$2/console" >/dev/null
  info "Console session started. Use 'pve' command in your browser to access."
  ;;

info)
  [[ $# -ne 2 ]] && usage && exit 1
  validate_ctid "$2"
  info "Getting detailed information for container $2..."
  format_ct_status "$2"
  echo ""

  # Get additional info
  ct_config=$(api GET "nodes/${NODE_NAME}/lxc/$2/config")
  echo "Configuration:"
  echo "$ct_config" | jq -r '.data | to_entries[] | "\(.key): \(.value)"' | head -10
  ;;

config)
  [[ $# -ne 2 ]] && usage && exit 1
  validate_ctid "$2"
  info "Getting configuration for container $2..."
  api GET "nodes/${NODE_NAME}/lxc/$2/config" | jq -r '.data | to_entries[] | "\(.key): \(.value)"'
  ;;

node-list)
  info "Listing all Proxmox nodes..."
  api GET "nodes" |
    jq -r '.data[] | "\(.node)\t\(.status)\t\(.cpu // "N/A")%\t\(.memory // 0 / 1024 / 1024 / 1024)GB\t\(.maxmem // 0 / 1024 / 1024 / 1024)GB"' |
    (echo -e "Node\tStatus\tCPU\tMemory\tMax Memory" && cat) |
    column -t
  ;;

version)
  info "Getting Proxmox VE version information..."
  api GET "version" | jq -r '.data | "Version: \(.version)\nRelease: \(.release)\nRepository: \(.repository)"'
  ;;

*)
  usage
  exit 1
  ;;
esac
