#! /usr/bin/env bash

set -euo pipefail

export DOT_DIR=${DOT_DIR:-$HOME/.ilm}
# shellcheck disable=SC1091
source "$DOT_DIR/share/utils"

readonly COMMUNITY_SCRIPTS_BASE="https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main"
readonly SCRIPT_LOG_FILE="/tmp/proxmox-scripts.log"
readonly SCRIPT_CACHE_DIR="/tmp/proxmox-scripts-cache"
readonly INTEGRITY_CHECKSUMS_FILE="${SCRIPT_CACHE_DIR}/checksums.txt"

# Ensure log and cache directories exist
mkdir -p "$(dirname "$SCRIPT_LOG_FILE")" "$SCRIPT_CACHE_DIR"

# Logging functions with different levels
log() {
  local level="$1"
  shift
  local message="$*"
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')

  # Log to file
  echo "[$timestamp] [$level] $message" >>"$SCRIPT_LOG_FILE"

  # Output to console with color coding
  case "$level" in
  "ERROR")
    echo -e "\033[1;31m[ERROR]\033[0m $message" >&2
    ;;
  "WARN")
    echo -e "\033[1;33m[WARN]\033[0m $message" >&2
    ;;
  "INFO")
    echo -e "\033[1;32m[INFO]\033[0m $message"
    ;;
  "DEBUG")
    echo -e "\033[1;36m[DEBUG]\033[0m $message" >&2
    ;;
  *)
    echo "[$level] $message"
    ;;
  esac
}

log_info() {
  log "INFO" "$@"
}

log_warn() {
  log "WARN" "$@"
}

log_error() {
  log "ERROR" "$@"
}

log_debug() {
  log "DEBUG" "$@"
}

# Check prerequisites
check_prerequisites() {
  log_info "Checking prerequisites..."

  local missing_deps=()

  # Check for required commands
  for cmd in curl whiptail bash; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_deps+=("$cmd")
    fi
  done

  # Check if running on Proxmox VE
  if [[ ! -f /etc/pve/.version ]] && [[ ! -f /usr/bin/pveversion ]]; then
    log_warn "This script is designed to run on Proxmox VE. Some features may not work correctly."
  fi

  # Check network connectivity
  if ! curl -s --connect-timeout 5 "https://raw.githubusercontent.com" >/dev/null; then
    log_error "Cannot connect to GitHub. Please check your internet connection."
    return 1
  fi

  # Report missing dependencies
  if [[ ${#missing_deps[@]} -gt 0 ]]; then
    log_error "Missing required dependencies: ${missing_deps[*]}"
    log_error "Please install the missing dependencies and try again."
    return 1
  fi

  log_info "All prerequisites satisfied."
  return 0
}

# Verify script integrity (optional)
verify_script_integrity() {
  local script_url="$1"
  local script_name
  script_name=$(basename "$script_url")
  local cached_script="${SCRIPT_CACHE_DIR}/${script_name}"
  local checksum_url="${script_url}.sha256"

  log_debug "Verifying integrity of $script_name"

  # Download the script
  if ! curl -fsSL "$script_url" -o "$cached_script"; then
    log_error "Failed to download script: $script_url"
    return 1
  fi

  # Calculate actual checksum
  local actual_checksum
  actual_checksum=$(sha256sum "$cached_script" | cut -d' ' -f1)

  # Try to find checksum in local cache first
  local expected_checksum=""
  if [[ -f "$INTEGRITY_CHECKSUMS_FILE" ]]; then
    expected_checksum=$(grep "^${script_name}:" "$INTEGRITY_CHECKSUMS_FILE" 2>/dev/null | cut -d':' -f2 || true)
  fi

  # If not in local cache, try to download from remote
  if [[ -z "$expected_checksum" ]]; then
    if curl -fsSL "$checksum_url" -o "${cached_script}.sha256" 2>/dev/null; then
      expected_checksum=$(cat "${cached_script}.sha256" | cut -d' ' -f1)
      # Cache the checksum for future use
      echo "${script_name}:${expected_checksum}" >>"$INTEGRITY_CHECKSUMS_FILE"
      log_debug "Downloaded and cached checksum for $script_name"
    else
      log_warn "No checksum available for $script_name, skipping verification"
      return 0
    fi
  fi

  # Verify checksum
  if [[ "$expected_checksum" != "$actual_checksum" ]]; then
    log_error "Checksum verification failed for $script_name"
    log_error "Expected: $expected_checksum"
    log_error "Actual: $actual_checksum"
    return 1
  fi

  log_debug "Checksum verification passed for $script_name"
  return 0
}

# Execute remote script with error handling
execute_remote_script() {
  local script_url="$1"
  local script_name
  script_name=$(basename "$script_url")

  log_info "Executing script: $script_name"

  # Verify script integrity if enabled
  if [[ "${VERIFY_INTEGRITY:-false}" == "true" ]]; then
    if ! verify_script_integrity "$script_url"; then
      log_error "Script integrity verification failed for $script_name"
      return 1
    fi
    # Execute from cache
    bash "${SCRIPT_CACHE_DIR}/${script_name}"
  else
    # Original behavior - execute directly
    if ! bash -c "$(curl -fsSL "$script_url")"; then
      log_error "Failed to execute script: $script_name"
      return 1
    fi
  fi

  log_info "Successfully executed script: $script_name"
  return 0
}

# Enhanced service installation functions with error handling
casaos-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/casaos.sh"
}

jellyfin-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/jellyfin.sh"
}

plex-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/plex.sh"
}

backup-server-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/proxmox-backup-server.sh"
}

docker-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/docker.sh"
}

dockge-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/dockge.sh"
}

adguard-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/adguard.sh"
}

pihole-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/pihole.sh"
  slog "Use 'pihole setpassword' to set password for Pi-hole"
}

authelia-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/authelia.sh"
}

duplicati-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/duplicati.sh"
}

deluge-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/deluge.sh"
}

qbittorrent_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/qbittorrent.sh"
}

rclone-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/rclone.sh"
  slog "Use 'htpasswd -b -B /opt/login.pwd newuser newuserpassword' to add new user"
}

syncthing-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/syncthing.sh"
}

paperless-ai_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/paperless-ai.sh"
}

ollama-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/ollama.sh"
}

caddy-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/caddy.sh"
}

nginx-proxy-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/nginxproxymanager.sh"
}

rustdesk-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/rustdeskserver.sh"
}

guacamole-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/apache-guacamole.sh"
}

vaultwarden-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/vaultwarden.sh"
}

backrest-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/backrest.sh"
}

uptime-kuma-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/uptimekuma.sh"
}

alpine-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/alpine.sh"
}

twofauth-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/2fauth.sh"
}

iventoy-lxc_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/ct/iventoy.sh"
}

docker-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/docker-vm.sh"
}

openwrt-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/openwrt.sh"
}

umbrel-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/umbrel-os-vm.sh"
}

opnsense-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/opnsense-vm.sh"
}

nextcloud-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/nextcloud-vm.sh"
}

ubuntu-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/ubuntu2504-vm.sh"
}

debian-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/debian-vm.sh"
}

arch-vm_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/vm/archlinux-vm.sh"
}

backup-server-lxc_post_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/tools/pve/post-pbs-install.sh"
}

code-server-addon_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/tools/addon/coder-code-server.sh"
}

tailscale-addon_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/tools/addon/add-tailscale-lxc.sh"
}

file-browser-addon_install() {
  execute_remote_script "${COMMUNITY_SCRIPTS_BASE}/tools/addon/filebrowser.sh"
}

# Enhanced dialog functions with error handling
show_dialog() {
  local -a options=("$@")
  local -a checklist_entries=()

  for option in "${options[@]}"; do
    checklist_entries+=("$option" "$option" "off")
  done

  local selected_output
  if ! selected_output=$(whiptail --separate-output --checklist "Select services to install" 20 60 15 \
    "${checklist_entries[@]}" \
    3>&1 1>&2 2>&3); then
    log_info "Selection cancelled by user."
    return 1
  fi

  local -a selected=()
  mapfile -t selected <<<"$selected_output"
  echo "${selected[@]}"
}

addon_dialog() {
  local -a addons=(
    "tailscale"
    "file-browser"
    "code-server"
  )
  show_dialog "${addons[@]}"
}

lxc_dialog() {
  local -a lxc_services=(
    "backup-server" "docker" "dockge" "adguard" "pihole"
    "authelia" "duplicati" "deluge" "qbittorrent" "rclone"
    "syncthing" "paperless-ai" "ollama" "caddy" "nginx-proxy"
    "rustdesk" "guacamole" "vaultwarden" "backrest"
    "uptime-kuma" "alpine" "twofauth" "iventoy"
  )
  show_dialog "${lxc_services[@]}"
}

vm_dialog() {
  local -a vm_services=(
    "docker" "openwrt" "umbrel" "opnsense"
    "nextcloud" "ubuntu" "debian" "arch"
  )
  show_dialog "${vm_services[@]}"
}

show_category_menu() {
  local category
  if ! category=$(whiptail --menu "Choose a service category" 15 40 5 \
    lxc "LXC containers" \
    addon "Addons" \
    vm "Virtual Machines" \
    3>&1 1>&2 2>&3); then
    log_info "Category selection cancelled by user."
    return 1
  fi

  echo "$category"
}

# Enhanced execute_service with error handling
execute_service() {
  local category="$1"
  local service="$2"
  local install_function="${service}-${category}_install"

  log_info "Installing $service ($category)..."

  if ! fn_exists "$install_function"; then
    log_error "Installation function not found: $install_function"
    return 1
  fi

  # Execute with error handling
  if ! "$install_function"; then
    log_error "Failed to install $service ($category)"
    return 1
  fi

  log_info "Successfully installed $service ($category)"
  return 0
}

# Show help information
show_help() {
  cat <<EOF
Proxmox Scripts Installer

USAGE:
    $0 [options] [service...]

OPTIONS:
    -h, --help          Show this help message
    -v, --verify        Enable script integrity verification
    -l, --log           Show log file location
    -c, --check         Check prerequisites only

EXAMPLES:
    $0                              # Interactive mode
    $0 docker-lxc pihole-lxc        # Install specific services
    $0 --verify docker-lxc          # Install with integrity verification
    $0 --check                      # Check prerequisites only

LOG FILE:
    $SCRIPT_LOG_FILE

For more information, see the log file.
EOF
}

# Main function with enhanced error handling
main() {
  # Parse command line options
  local verify_integrity=false
  local check_only=false
  local services=()

  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_help
      exit 0
      ;;
    -v | --verify)
      verify_integrity=true
      shift
      ;;
    -l | --log)
      echo "Log file: $SCRIPT_LOG_FILE"
      exit 0
      ;;
    -c | --check)
      check_only=true
      shift
      ;;
    -*)
      log_error "Unknown option: $1"
      show_help
      exit 1
      ;;
    *)
      services+=("$1")
      shift
      ;;
    esac
  done

  # Set integrity verification flag
  if [[ "$verify_integrity" == "true" ]]; then
    export VERIFY_INTEGRITY=true
    log_info "Script integrity verification enabled"
  fi

  # Check prerequisites
  if ! check_prerequisites; then
    log_error "Prerequisites check failed"
    exit 1
  fi

  # If only checking prerequisites, exit here
  if [[ "$check_only" == "true" ]]; then
    log_info "Prerequisites check completed successfully"
    exit 0
  fi

  # Log script start
  log_info "Starting Proxmox Scripts Installer"
  log_info "Command: $0 $*"

  # Command line mode
  if [[ ${#services[@]} -gt 0 ]]; then
    log_info "Command line mode: Installing specified services"
    local failed_services=()

    for service in "${services[@]}"; do
      if fn_exists "${service}_install"; then
        log_info "Installing ${service}..."
        if ! "${service}_install"; then
          failed_services+=("$service")
        fi
      else
        log_error "No installer found for $service"
        failed_services+=("$service")
      fi
    done

    # Report results
    if [[ ${#failed_services[@]} -gt 0 ]]; then
      log_error "Failed to install services: ${failed_services[*]}"
      exit 1
    else
      log_info "All services installed successfully"
    fi

    exit 0
  fi

  # Interactive mode
  log_info "Interactive mode: Showing service selection menu"

  local category
  if ! category=$(show_category_menu); then
    log_info "No category selected, exiting"
    exit 0
  fi

  local -a selected

  case "$category" in
  lxc)
    if ! read -r -a selected < <(lxc_dialog); then
      log_info "No LXC services selected, exiting"
      exit 0
    fi
    ;;
  addon)
    if ! read -r -a selected < <(addon_dialog); then
      log_info "No addon services selected, exiting"
      exit 0
    fi
    ;;
  vm)
    if ! read -r -a selected < <(vm_dialog); then
      log_info "No VM services selected, exiting"
      exit 0
    fi
    ;;
  *)
    log_error "Invalid selection: $category"
    exit 1
    ;;
  esac

  if [[ ${#selected[@]} -eq 0 ]]; then
    log_info "No services selected, exiting"
    exit 0
  fi

  log_info "Selected services: ${selected[*]}"

  local failed_services=()
  for service in "${selected[@]}"; do
    if ! execute_service "$category" "$service"; then
      failed_services+=("$service")
    fi
  done

  # Report final results
  if [[ ${#failed_services[@]} -gt 0 ]]; then
    log_error "Failed to install services: ${failed_services[*]}"
    log_error "Check the log file for details: $SCRIPT_LOG_FILE"
    exit 1
  else
    log_info "All services installed successfully!"
    log_info "Installation completed. Check the log file for details: $SCRIPT_LOG_FILE"
  fi
}

# Execute main function with all arguments
main "$@"
