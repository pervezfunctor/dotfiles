#!/usr/bin/env bash

# shellcheck disable=SC1091

set -euo pipefail -o errtrace

export DOT_DIR=${DOT_DIR:-"$HOME/.ilm"}

source "$DOT_DIR/share/utils"
source "$(dirname "$0")/utils"

DISTRO=""
CT_ID=""
HOSTNAME=""
MEMORY="4096"
CPU="2"
STORAGE=""
DISK_SIZE="8"
TEMPLATE_DIR="/var/lib/vz/template/cache"
BRIDGE="vmbr0"
TEMPLATE=""
PASSWORD="program"

parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    --distro | -d)
      DISTRO="$2"
      shift 2
      ;;
    --id)
      CT_ID="$2"
      shift 2
      ;;
    --hostname)
      HOSTNAME="$2"
      shift 2
      ;;
    --memory)
      MEMORY="$2"
      shift 2
      ;;
    --cpu)
      CPU="$2"
      shift 2
      ;;
    --storage)
      STORAGE="$2"
      shift 2
      ;;
    --disk-size)
      DISK_SIZE="$2"
      shift 2
      ;;
    --template-dir)
      TEMPLATE_DIR="$2"
      shift 2
      ;;
    --bridge)
      BRIDGE="$2"
      shift 2
      ;;
    --password)
      PASSWORD="$2"
      shift 2
      ;;
    *)
      echo "Error: Unknown option $1" >&2
      return 1
      ;;
    esac
  done

  if [[ -z "$DISTRO" || -z "$CT_ID" ]]; then
    echo "Error: Both --distro and --id are required" >&2
    return 1
  fi

  if ! TEMPLATE=$(template_for_distro "$DISTRO"); then
    fail "Failed to find template for distro $DISTRO"
    return 1
  fi

  return 0
}

validate_args() {
  if [[ -z "$DISTRO" ]]; then
    echo "Error: Distribution is required" >&2
    return 1
  fi

  if ! validate_ct_id "$CT_ID"; then
    return 1
  fi

  # Check if VM with same ID exists
  if qm status "$CT_ID" &>/dev/null; then
    echo "Error: VM with ID $CT_ID already exists" >&2
    return 1
  fi

  if ! validate_positive_integer "$MEMORY" "Memory must be a positive integer"; then
    return 1
  fi

  if ! validate_positive_integer "$CPU" "CPU must be a positive integer"; then
    return 1
  fi

  # Auto-detect storage if not provided
  if [[ -z "$STORAGE" ]]; then
    if ! STORAGE=$(detect_storage); then
      return 1
    fi
    echo "Auto-detected storage: $STORAGE üíæ"
  else
    if ! pvesm status | grep -q "^$STORAGE "; then
      fail "Storage '$STORAGE' not found or not accessible"
      return 1
    fi
  fi

  if ! brctl show | grep -q "^${BRIDGE}[[:space:]]"; then
    fail "Network bridge '$BRIDGE' not found or not accessible"
    return 1
  fi

  if ! validate_positive_integer "$DISK_SIZE" "Disk size must be a positive integer"; then
    return 1
  fi

  if ! find "$TEMPLATE_DIR" -name "${DISTRO}-*" -type f | grep -q "."; then
    echo "Error: No templates found for distro '$DISTRO' in $TEMPLATE_DIR" >&2
    return 1
  fi

  if [[ -z "$HOSTNAME" ]]; then
    HOSTNAME=$(hostname_from_template "$TEMPLATE" "ct")
  fi

  return 0
}

usage() {
  cat <<EOF
Usage: $(basename "$0") --distro|-d <distro> --id <ct_id> [OPTIONS]

Create a Proxmox LXC container from a template.

Required Options:
  --distro, -d    Distribution name (e.g., ubuntu, debian, fedora)
  --id             Container ID (must be a number between 100-255)

Optional Options:
  --hostname       Container hostname (auto-generated if not provided)
  --memory         Memory in MB (default: 4096)
  --cpu            Number of CPU cores (default: 2)
  --storage        Storage location (auto-detects local-zfs or local-lvm if not provided)
  --disk-size      Disk size (default: 8 gigabytes)
  --template-dir   Template directory path (default: /var/lib/vz/template/cache)
  --bridge         Network bridge (default: vmbr0)
  --password       Root password for the container (default: empty)

Examples:
  $(basename "$0") --distro ubuntu --id 100
  $(basename "$0") -d debian --id 101 --hostname my-container
  $(basename "$0") -d ubuntu --id 102 --memory 8192 --cpu 4
  $(basename "$0") -d fedora --id 103 --disk-size 16G --storage local-zfs
  $(basename "$0") -d debian --id 104 --template-dir /custom/template/path --bridge vmbr1
  $(basename "$0") -d ubuntu --id 105 --password mysecretpassword

EOF
}

main() {
  if [[ $# -gt 0 && ("$1" == "--help" || "$1" == "-h") ]]; then
    usage
    exit 0
  fi

  if [[ $# -eq 0 ]] || ! parse_args "$@" || ! validate_args; then
    usage
    exit 1
  fi

  echo "üöÄ Creating LXC from template: $TEMPLATE with ID: $CT_ID"

  echo "üè∑Ô∏è Using hostname: $HOSTNAME for template: $TEMPLATE"
  echo "üíæ Memory: ${MEMORY}MB, CPU: $CPU, Storage: $STORAGE", "Disk: ${DISK_SIZE}G"
  sleep 2

  local rootfs_param
  rootfs_param="${STORAGE}:${DISK_SIZE}"

  if [[ ! -f "$TEMPLATE_DIR/$TEMPLATE" ]]; then
    fail "Template file not found: $TEMPLATE_DIR/$TEMPLATE"
    return 1
  fi

  local pct_create_args=(
    "$CT_ID"
    "$TEMPLATE_DIR/$TEMPLATE"
    --hostname "$HOSTNAME"
    --memory "$MEMORY"
    --cores "$CPU"
    --rootfs "$rootfs_param"
    --net0 "name=eth0,bridge=$BRIDGE,ip=dhcp,firewall=1"
    --console 1
    --unprivileged 1
    --features nesting=1
    --password "$PASSWORD"
  )

  if ! pct create "${pct_create_args[@]}"; then
    fail "Failed to create LXC from $TEMPLATE"
    return 1
  fi

  pct start "$CT_ID"

  # Wait for container to be fully ready
  echo "‚è≥ Waiting for container to initialize..."
  if wait_for_ct "$CT_ID" 60; then
    echo "‚úÖ Container is ready!"
  else
    echo "‚ö†Ô∏è  Container started but may not be fully ready"
  fi

  # # Additional setup for better systemd support
  # echo "üîß Configuring systemd services..."

  # # Create necessary directories that systemd services need
  # pct exec "$CT_ID" -- mkdir -p /run/lock /var/log/journal /dev/mqueue || true

  # # Setup journal persistence
  # pct exec "$CT_ID" -- systemd-tmpfiles --create --prefix /var/log/journal || true

  # # Restart systemd services to ensure proper initialization
  # pct exec "$CT_ID" -- systemctl daemon-reload || true
  # pct exec "$CT_ID" -- systemctl restart systemd-journald || true

  # # Enable console services
  # pct exec "$CT_ID" -- systemctl enable getty@tty1.service || true
  # pct exec "$CT_ID" -- systemctl start getty@tty1.service || true

  echo "‚úÖ LXC creation from template $TEMPLATE with ID $CT_ID done!"
  return 0
}

main "$@"
