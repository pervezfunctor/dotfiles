#! /usr/bin/env bash

set -euo pipefail

DOT_DIR=${DOT_DIR:-"$HOME/.ilm"}
# shellcheck disable=SC1091
source "$DOT_DIR/share/utils"

container_exists() {
  pct status "$1" &>/dev/null
}

check_container() {
  if ! container_exists "$1"; then
    fail "Container '$1' does not exist"
    return 1
  fi
}

container_privileged() {
  grep -q '^unprivileged: 0' "/etc/pve/lxc/$1.conf"
}

choose_from_list() {
  local -n arr="$1"

  if [ "${#arr[@]}" -eq 0 ]; then
    echo "No options available."
    return 1
  fi

  local i
  for i in "${!arr[@]}"; do
    echo "[$i] ${arr[$i]}"
  done

  local choice
  while true; do
    read -r -p "Select number: " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt "${#arr[@]}" ]; then
      echo "${arr[$choice]}"
      return 0
    else
      echo "Invalid selection."
    fi
  done
}

lxc_templates() {
  pveam available
}

supported_lxc_distros() {
  local distros=(
    "ubuntu"
    "debian"
    "fedora"
    # "archlinux"
    # "alpine"
    # "centos"
    # "rockylinux"
    # "opensuse"
  )

  echo "${distros[@]}"
}

read_template() {
  local templates
  templates=$(pveam available)
  echo "$templates" | gum choose --header="Select LXC Template"
}

scaling_governor_setup() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/scaling-governor.sh)"
}

simple_backup() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/host-backup.sh)"
}

kernel_clean() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/kernel-clean.sh)"
}

kernel_pin() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/kernel-pin.sh)"
}

lxc_trim() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/fstrim.sh)"
}

monitoring_setup() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/monitor-all.sh)"
}

lxc_update() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/update-lxcs.sh)"
}

vm_exists() {
  qm status "$1" &>/dev/null
}

check_vm() {
  if ! vm_exists "$1"; then
    fail "VM '$1' does not exist"
    return 1
  fi
}

vm_is_template() {
  grep -q '^template: 1' "/etc/pve/qemu-server/$1.conf"
}

vm_create() {
  local template_id="$1"
  local vm_name="${2:-}"
  local vm_id="${3:-}"

  if [[ -z "$template_id" ]]; then
    fail "Template ID is required"
    return 1
  fi

  check_vm "$template_id" || return 1

  if ! vm_is_template "$template_id"; then
    fail "VM '$template_id' is not a template"
    return 1
  fi

  # Auto-generate VM ID if not provided
  if [[ -z "$vm_id" ]]; then
    vm_id=$(qm list | awk 'NR>1 && $2 !~ /template/ {print $1}' | sort -n | tail -n 1)
    vm_id=${vm_id:-99}
    vm_id=$((vm_id + 1))
  fi

  # Auto-generate VM name if not provided
  if [[ -z "$vm_name" ]]; then
    vm_name="vm-$vm_id"
  fi

  echo "Cloning VM from template $template_id to new VM $vm_id ($vm_name)..."

  qm clone "$template_id" "$vm_id" --name "$vm_name" --full

  echo "Waiting for VM clone to complete..."
  sleep 2

  echo "âœ… VM $vm_id ($vm_name) created successfully from template $template_id"
}

vm_templates() {
  echo "Available VM templates:"
  qm list | awk 'NR>1 && $2 ~ /template/ {print $1 " " $2}'
}

vm_update() {
  bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/update-vms.sh)"
}

template_for_distro() {
  local distro="$1"
  local template_dir="/var/lib/vz/template/cache"

  local latest_template
  latest_template=$(find "$template_dir" -name "${distro}-*" -type f | sort -V | tail -n 1 2>/dev/null)

  if [[ -z "$latest_template" ]]; then
    echo "Error: No template found for distro '$distro' in $template_dir" >&2
    return 1
  fi

  basename "$latest_template"
}

hostname_from_template() {
  local template_name="$1"
  local suffix="${2:-ct}"

  if [[ -z "$template_name" ]]; then
    fail "Template name is required for hostname generation"
    return 1
  fi

  local distro_name
  distro_name=$(echo "$template_name" | cut -d'-' -f1 | sed 's/_.*//')

  distro_name=$(echo "$distro_name" | tr '[:upper:]' '[:lower:]')

  local hostname="${distro_name}-${suffix}"
  hostname=$(echo "$hostname" | sed 's/[^a-z0-9-]//g' | sed 's/--*/-/g')

  echo "$hostname"
}

validate_positive_integer() {
  local value="$1"
  local error_message="${2:-Value must be a positive integer}"

  if [[ ! "$value" =~ ^[0-9]+$ ]]; then
    echo "Error: $error_message" >&2
    return 1
  fi

  if [[ "$value" -lt 0 ]]; then
    echo "Error: $error_message" >&2
    return 1
  fi

  return 0
}

validate_ct_id() {
  local ct_id="$1"

  if ! validate_positive_integer "$ct_id" "Container ID must be a positive integer"; then
    return 1
  fi

  if [[ "$ct_id" -lt 100 || "$ct_id" -gt 255 ]]; then
    echo "Error: Container ID must be between 100 and 255" >&2
    return 1
  fi

  if pct status "$ct_id" &>/dev/null; then
    echo "Error: Container with ID $ct_id already exists" >&2
    return 1
  fi

  return 0
}

wait_for_ct() {
  local CT_ID="$1"
  local timeout="${2:-60}" # default 60s
  local start_time status

  start_time=$(date +%s)

  while true; do
    status=$(pct status "$CT_ID" | awk '{print $2}')
    if [ "$status" = "running" ]; then
      if pct exec "$CT_ID" -- true &>/dev/null; then
        return 0
      fi
    fi

    # timeout
    if (($(date +%s) - start_time > timeout)); then
      echo "Timeout waiting for CT $CT_ID to become ready" >&2
      return 1
    fi
    sleep 1
  done
}
