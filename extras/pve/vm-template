#!/usr/bin/env bash

# shellcheck disable=SC1091

set -euo pipefail

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
readonly SCRIPT_NAME

readonly IMAGES_DIR="/var/lib/vz/template/cache"

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "$SCRIPT_DIR/utils"

DISK_SIZE="32G"
MEMORY="8192"
CORES="4"

log_info() {
  echo "â„¹ï¸  [INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_warn() {
  echo "âš ï¸  [WARN] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

log_error() {
  echo "âŒ [ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

die() {
  log_error "$1"
  exit 1
}

log_debug() {
  if [[ "${DEBUG:-0}" == "1" ]]; then
    echo "ğŸ› [DEBUG] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
  fi
}

log_success() {
  echo "âœ… [SUCCESS] $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

cleanup_on_error() {
  local exit_code=$?
  if [[ $exit_code -ne 0 ]]; then
    log_error "Script failed with exit code $exit_code"

    if [[ -n "${VM_ID:-}" ]] && qm status "$VM_ID" &>/dev/null; then
      log_warn "Cleaning up partially created VM $VM_ID"
      qm destroy "$VM_ID" --destroy-unreferenced-disks 1 &>/dev/null || true
    fi
  fi
  exit $exit_code
}

trap cleanup_on_error EXIT INT TERM

validate_vm_id() {
  local vm_id="$1"
  if ! [[ "$vm_id" =~ ^[0-9]+$ ]]; then
    log_error "VM ID must be a positive integer"
    return 1
  fi

  if qm status "$vm_id" &>/dev/null; then
    log_error "VM with ID $vm_id already exists"
    return 1
  fi

  return 0
}

validate_disk_size() {
  local disk_size="$1"
  if ! [[ "$disk_size" =~ ^[0-9]+[KMGT]? ]]; then
    log_error "Invalid disk size format: $disk_size. Use format like '32G', '1024M', etc."
    return 1
  fi
  return 0
}

validate_memory() {
  local memory="$1"
  if ! [[ "$memory" =~ ^[0-9]+$ ]] || [[ "$memory" -lt 512 ]]; then
    log_error "Memory must be a positive integer >= 512 MB"
    return 1
  fi
  return 0
}

validate_cores() {
  local cores="$1"
  if ! [[ "$cores" =~ ^[0-9]+$ ]] || [[ "$cores" -lt 1 ]]; then
    log_error "CPU cores must be a positive integer >= 1"
    return 1
  fi
  return 0
}

validate_storage() {
  local storage=${PROXMOX_STORAGE:-}
  log_debug "Validating storage: $storage"

  if [[ -z "$storage" ]]; then
    log_info "No storage specified, detecting suitable storage..."
    if ! storage=$(detect_storage); then
      log_error "Failed to detect suitable storage"
      return 1
    fi
    PROXMOX_STORAGE="$storage"
    log_info "Auto-detected storage: $storage"
  elif ! pvesm status | grep -q "^$storage "; then
    log_error "Storage '$storage' not found or not accessible"
    log_debug "Available storages: $(pvesm status)"
    return 1
  fi

  log_debug "Storage validation passed for: $storage"
  return 0
}

validate_credentials() {
  if [[ -z "$USERNAME" ]]; then
    log_error "Username cannot be empty"
    return 1
  fi

  if [[ -z "$PASSWORD" ]]; then
    log_warn "No  password provided. You will need to set one manually."
  fi

  return 0
}

validate_vm_name() {
  if qm list 2>/dev/null | awk -v name="$VM_NAME" '$2 == name { found=1 } END { exit !found }'; then
    log_error "VM name '$VM_NAME' is already in use. Please specify a different name with -n"
    return 1
  fi
  return 0
}

validate_distro() {
  if [[ -z "${DISTRO:=}" ]]; then
    log_error "The --distro argument is required. Use -h for help."
    return 1
  fi
  return 0
}

validate_all_parameters() {
  validate_distro || return 1
  validate_vm_id "$VM_ID" || return 1
  validate_vm_name || return 1
  validate_disk_size "$DISK_SIZE" || return 1
  validate_memory "$MEMORY" || return 1
  validate_cores "$CORES" || return 1
  validate_storage || return 1
  validate_credentials || return 1

  return 0
}

usage() {
  echo
  sleep 1

  cat <<EOF
ğŸš€ Usage: $SCRIPT_NAME -D DISTRO [OPTIONS]

ğŸ“‹ Required:
  -D, --distro DISTRO              ğŸ§ Distribution: debian, fedora, ubuntu, alpine, centos, tumbleweed, or arch

ğŸ“‹ Options:
  -s, --storage STORAGE            ğŸ’¾ Proxmox storage target (default: auto-detect)
  -i, --vm-id VM_ID                ğŸ”¢ Unique ID for the new VM (default: auto-assigned)
  -n, --vm-name VM_NAME            ğŸ·ï¸  Name for the VM (default: auto-assigned)
  -d, --disk-size DISK_SIZE        ğŸ’¿ Size of the VM disk (default: 32G)
  -m, --memory MEMORY               ğŸ§  VM memory in MB (default: 8192)
  -c, --cpu CORES                   âš™ï¸  Number of CPU cores (default: 4)
  -u, --username USERNAME           ğŸ‘¤ Username for cloud-init (default: distro-specific)
  -p, --password PASSWORD           ğŸ” Password for cloud-init (default: program, use CLOUD_INIT_PASSWORD to override)
  -h, --help                        â“ Display this help message
  --debug                           ğŸ› Enable debug logging

ğŸ“ Examples:
  $SCRIPT_NAME -D debian
  $SCRIPT_NAME -D centos -s custom-storage  # Use specific storage
EOF
}

parse_args() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  while [[ "$#" -gt 0 ]]; do
    case $1 in
    -D | --distro)
      DISTRO="$2"
      shift 2
      ;;
    -s | --storage)
      PROXMOX_STORAGE="$2"
      shift 2
      ;;
    -i | --vm-id)
      VM_ID="$2"
      shift 2
      ;;
    -n | --vm-name)
      VM_NAME="$2"
      shift 2
      ;;
    -d | --disk-size)
      DISK_SIZE="$2"
      shift 2
      ;;
    -m | --memory)
      MEMORY="$2"
      shift 2
      ;;
    -c | --cpu)
      CORES="$2"
      shift 2
      ;;
    -u | --username)
      USERNAME="$2"
      shift 2
      ;;
    -p | --password)
      PASSWORD="$2"
      shift 2
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    --debug)
      export DEBUG=1
      shift
      ;;
    *)
      log_error "Unknown parameter: $1"
      usage
      ;;
    esac
  done
}

check_prerequisites() {
  check_root_user

  if ! has_cmd qm; then
    log_error "The 'qm' command is required. This script must be run on a Proxmox host."
    exit 1
  fi

  local required_tools=("wget" "awk")
  for tool in "${required_tools[@]}"; do
    if ! has_cmd "$tool"; then
      log_error "Required tool '$tool' not found"
    fi
  done
}

configure_distribution() {
  slog "Configuring distribution: $DISTRO"

  case "$DISTRO" in
  debian)
    VM_ID=${VM_ID:-201}
    VM_NAME=${VM_NAME:-debian-template}
    IMAGE_URL=${IMAGE_URL:-"https://cdimage.debian.org/cdimage/cloud/trixie/latest/debian-13-genericcloud-amd64.qcow2"}
    USERNAME=${USERNAME:-debian}
    ;;
  fedora)
    VM_ID=${VM_ID:-202}
    VM_NAME=${VM_NAME:-fedora-template}
    IMAGE_URL=${IMAGE_URL:-"https://mirror.twds.com.tw/fedora/fedora/linux/releases/43/Cloud/x86_64/images/Fedora-Cloud-Base-Generic-43-1.6.x86_64.qcow2"}
    USERNAME=${USERNAME:-fedora}
    ;;
  ubuntu)
    VM_ID=${VM_ID:-203}
    VM_NAME=${VM_NAME:-ubuntu-template}
    IMAGE_URL=${IMAGE_URL:-"https://cloud-images.ubuntu.com/questing/current/questing-server-cloudimg-amd64.img"}
    USERNAME=${USERNAME:-ubuntu}
    ;;
  alpine)
    VM_ID=${VM_ID:-204}
    VM_NAME=${VM_NAME:-alpine-template}
    IMAGE_URL=${IMAGE_URL:-"https://dl-cdn.alpinelinux.org/alpine/v3.22/releases/cloud/generic_alpine-3.22.2-x86_64-uefi-cloudinit-r0.qcow2"}
    USERNAME=${USERNAME:-alpine}
    ;;
  centos)
    VM_ID=${VM_ID:-205}
    VM_NAME=${VM_NAME:-centos-template}
    IMAGE_URL=${IMAGE_URL:-"https://cloud.centos.org/centos/10-stream/x86_64/images/CentOS-Stream-GenericCloud-10-20241118.0.x86_64.qcow2"}
    USERNAME=${USERNAME:-centos}
    ;;
  tumbleweed | tw)
    VM_ID=${VM_ID:-206}
    VM_NAME=${VM_NAME:-tumbleweed-template}
    IMAGE_URL=${IMAGE_URL:-"https://download.opensuse.org/tumbleweed/appliances/openSUSE-Tumbleweed-Minimal-VM.x86_64-Cloud.qcow2"}
    USERNAME=${USERNAME:-opensuse}
    ;;
  arch)
    VM_ID=${VM_ID:-207}
    VM_NAME=${VM_NAME:-arch-template}
    IMAGE_URL=${IMAGE_URL:-"https://geo.mirror.pkgbuild.com/images/latest/Arch-Linux-x86_64-cloudimg.qcow2"}
    USERNAME=${USERNAME:-arch}
    ;;
  *)
    log_error "Unsupported distribution: '$DISTRO'. Supported: debian, fedora, ubuntu, centos, tumbleweed, arch"
    ;;
  esac
  PASSWORD=${PASSWORD:-$USERNAME}
}

download_image() {
  local filename
  filename=$(basename "$IMAGE_URL")
  local temp_image_path="$IMAGES_DIR/$filename"
  TEMP_IMAGE_PATH="$temp_image_path"

  echo "ğŸ“¥ Downloading $DISTRO image from $IMAGE_URL..."

  if [[ -f "$temp_image_path" ]]; then
    log_success "Image already exists at $temp_image_path"
    return 0
  fi

  mkdir -p "$IMAGES_DIR"

  log_info "Downloading image from $IMAGE_URL..."

  if ! wget -O "$temp_image_path" "$IMAGE_URL"; then
    log_error "Failed to download $DISTRO image from $IMAGE_URL"
    return 1
  fi

  if [[ ! -f "$temp_image_path" ]] || [[ ! -s "$temp_image_path" ]]; then
    log_error "Downloaded image file is empty or missing"
    return 1
  fi

  log_success "Successfully downloaded image to $temp_image_path"
  return 0
}

resize_disk() {
  echo "ğŸ“ Resizing disk to $DISK_SIZE..."

  if ! qm resize "$VM_ID" "scsi0" "$DISK_SIZE"; then
    log_error "Failed to resize disk"
    return 1
  fi

  log_success "Disk resized successfully"
  return 0
}

configure_cloud_init() {
  echo "â˜ï¸  Adding cloud-init drive..."

  local cloud_init_args=(
    "$VM_ID"
    --serial0 socket
    --vga serial0
    --ipconfig0 ip=dhcp
    --ciuser "$USERNAME"
  )

  local pub_key_path=""

  if [[ -f /root/.ssh/id_ed25519.pub ]]; then
    pub_key_path=/root/.ssh/id_ed25519.pub
  elif [[ -f /root/.ssh/id_rsa.pub ]]; then
    pub_key_path=/root/.ssh/id_rsa.pub
  fi

  if [[ -n "$pub_key_path" ]]; then
    cloud_init_args+=(--sshkey "$pub_key_path")
    log_info "SSH public key added to cloud-init configuration: $pub_key_path"
  else
    log_warn "No SSH public key found under /root/.ssh - proceeding without it"
  fi

  if [[ -n "$PASSWORD" ]]; then
    cloud_init_args+=(--cipassword "$PASSWORD")
    log_info "Password authentication configured"
  else
    log_warn "No password provided - you'll need to set one manually"
  fi

  if ! qm set "${cloud_init_args[@]}"; then
    log_error "Failed to configure cloud-init"
    return 1
  fi

  log_success "Cloud-init configuration completed"
  return 0
}

create_vm() {
  echo "ğŸ–¥ï¸  Creating VM '$VM_NAME' with ID $VM_ID..."

  local bios_type="ovmf"
  if [[ "$DISTRO" == "arch" || "$DISTRO" == "centos" ]]; then
    bios_type="seabios"
  fi

  local qm_create_args=(
    "$VM_ID"
    --name "$VM_NAME"
    --memory "$MEMORY"
    --cores "$CORES"
    --machine q35
    --cpu host
    --agent enabled=1
    --net0 "virtio,bridge=vmbr0"
    --scsihw virtio-scsi-pci
    --bios "$bios_type"
  )

  if ! qm create "${qm_create_args[@]}"; then
    log_error "Failed to create VM"
    return 1
  fi

  log_info "Importing disk image..."
  if ! qm importdisk "$VM_ID" "$TEMP_IMAGE_PATH" "$PROXMOX_STORAGE"; then
    log_error "Failed to import disk"
    qm destroy "$VM_ID" 2>/dev/null
    return 1
  fi

  log_info "Configuring disks and boot order..."
  local qm_set_args=(
    "$VM_ID"
    --scsi0 "$PROXMOX_STORAGE:vm-$VM_ID-disk-0,discard=on,ssd=1"
    --ide2 "$PROXMOX_STORAGE:cloudinit"
    --boot order=scsi0
    --serial0 socket
    --vga serial0
    --tags "template,${DISTRO}"
  )

  if [[ "$DISTRO" != "arch" && "$DISTRO" != "centos" ]]; then
    qm_set_args+=(--efidisk0 "$PROXMOX_STORAGE:1,efitype=4m,pre-enrolled-keys=1")
  fi

  if ! qm set "${qm_set_args[@]}"; then
    log_error "Failed to configure VM disks"
    qm destroy "$VM_ID" 2>/dev/null
    return 1
  fi

  resize_disk && configure_cloud_init && log_info "VM $VM_ID created successfully"
  return 0
}

convert_to_template() {
  echo "ğŸ“¦ Converting VM to template..."

  if ! qm template "$VM_ID"; then
    log_error "Failed to convert VM to template"
    return 1
  fi

  log_success "Template conversion completed"
  return 0
}

display_configuration() {
  echo "ğŸ“‹ Configuration:"
  echo "  ğŸ§ Distribution: $DISTRO"
  echo "  ğŸ”¢ VM ID: $VM_ID"
  echo "  ğŸ·ï¸  VM Name: $VM_NAME"
  echo "  ğŸ’¾ Storage: $PROXMOX_STORAGE"
  echo "  ğŸ’¿ Disk Size: $DISK_SIZE"
  echo "  ğŸ§  Memory: $MEMORY MB"
  echo "  âš™ï¸  CPU Cores: $CORES"
  echo "  ğŸ‘¤ Username: $USERNAME"
  echo "  ğŸ” Password: ${PASSWORD:+[SET]}${PASSWORD:-[NOT SET]}"
  echo "  ğŸŒ Image URL: $IMAGE_URL"
}

main() {
  echo "ğŸš€ Starting Proxmox VM template creation process"

  parse_args "$@"

  check_prerequisites || exit 1
  configure_distribution || exit 1

  validate_all_parameters || exit 1
  display_configuration

  download_image || exit 1
  create_vm || exit 1
  convert_to_template || exit 1

  display_configuration
  log_success "$DISTRO template '$VM_NAME' (ID: $VM_ID) created successfully!"
  log_info "You can now clone this template to create new VMs"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
