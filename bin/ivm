#!/bin/bash

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }

# Source Incus functions if available
DOT_DIR=${DOT_DIR:-$HOME/.ilm}
if [[ -f "$DOT_DIR/share/fns" ]]; then
    # shellcheck disable=SC1091
    source "$DOT_DIR/share/fns"
fi

usage() {
    cat <<EOF
Usage: $0 <command> [vm-name] [args...]

Manage Incus virtual machines similar to libvirt VM management.

COMMANDS:
    install                 Install Incus using ilmi
    list                    List all Incus VMs
    status <name>           Show VM status and info
    create <distro> [name]  Create a new Incus VM
    start <name>            Start a VM
    stop <name>             Stop a VM
    restart <name>          Restart a VM
    delete <name>           Delete a VM completely
    console <name>          Connect to VM console
    exec <name> <cmd>       Execute command in VM
    ip <name>               Get VM IP address
    ssh <name> [username]   Connect to VM via SSH
    info <name>             Show detailed VM information
    config <name>           Show VM configuration
    snapshot <name> [snap]  Create VM snapshot
    restore <name> <snap>   Restore VM from snapshot
    copy <src> <dest>       Copy VM
    cleanup                 Remove stopped VMs

SUPPORTED DISTROS:
    ubuntu, fedora, arch, tumbleweed, debian, centos, alpine

EXAMPLES:
    $0 install                      # Install Incus
    $0 list                         # List all VMs
    $0 status ubuntu-vm             # Show status of 'ubuntu-vm'
    $0 create ubuntu myubuntu       # Create Ubuntu VM named 'myubuntu'
    $0 create fedora                # Create Fedora VM with default name
    $0 console ubuntu-vm            # Connect to VM console
    $0 exec ubuntu-vm "ls -la"      # Run command in VM
    $0 ip ubuntu-vm                 # Get IP address of 'ubuntu-vm'
    $0 ssh ubuntu-vm                # SSH to 'ubuntu-vm' (auto-detect username)
    $0 ssh ubuntu-vm ubuntu         # SSH to 'ubuntu-vm' as 'ubuntu' user
    $0 snapshot ubuntu-vm backup    # Create snapshot named 'backup'
    $0 delete old-vm                # Delete 'old-vm' completely

EOF
}

check_incus() {
    if ! command -v incus >/dev/null 2>&1; then
        log_error "incus command not found. Please install Incus first."
        log_info "You can install it with: $0 install"
        return 1
    fi
}

# Helper function to list VMs with fallback for older Incus versions
incus_list_vms() {
    local vm_name="${1:-}"
    local extra_args="${2:-}"

    # Check if server is reachable
    if ! incus info >/dev/null 2>&1; then
        log_error "Incus server is not reachable. Please initialize it first:"
        log_info "  sudo incus admin init --minimal"
        log_info "  newgrp incus"
        return 1
    fi

    # Try with --type flag first, fallback if not supported
    if [[ -n "$vm_name" ]]; then
        # For specific VM
        if incus list "$vm_name" --type=virtual-machine "${extra_args}" >/dev/null 2>&1; then
            incus list "$vm_name" --type=virtual-machine "${extra_args}"
        else
            incus list "$vm_name" "${extra_args}"
        fi
    else
        # For all VMs
        if incus list --type=virtual-machine "${extra_args}" >/dev/null 2>&1; then
            incus list --type=virtual-machine "${extra_args}"
        else
            incus list "${extra_args}"
        fi
    fi
}

install_incus() {
    log_info "Installing Incus using ilmi..."

    # Check if ilmi is available
    if ! command -v ilmi >/dev/null 2>&1; then
        log_error "ilmi not found. Installing it first..."

        # Install ilmi
        if command -v curl >/dev/null 2>&1; then
            bash -c "$(curl -sSL https://dub.sh/aPKPT8V)" -- incus
        elif command -v wget >/dev/null 2>&1; then
            bash -c "$(wget -qO- https://dub.sh/aPKPT8V)" -- incus
        else
            log_error "Neither curl nor wget found. Please install one of them first."
            return 1
        fi
    else
        # Use existing ilmi
        ilmi incus
    fi

    if command -v incus >/dev/null 2>&1; then
        log_success "Incus installed successfully!"
        log_info "You may need to log out and back in for group changes to take effect."
        log_info "Or run: newgrp incus"
        echo
        log_info "You can now use:"
        log_info "  $0 list                    # List VMs"
        log_info "  $0 create ubuntu           # Create Ubuntu VM"
        log_info "  ivm-create --distro ubuntu  # Create VM with cloud-init and SSH"
    else
        log_error "Incus installation failed. Please check the output above for errors."
        return 1
    fi
}

list_vms() {
    check_incus || return 1

    log_info "Listing all Incus VMs..."
    echo
    incus_list_vms
}

vm_status() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    log_info "Status for VM '$vm_name':"
    echo
    incus_list_vms "$vm_name"
    echo

    log_info "Detailed information:"
    incus info "$vm_name" | head -20
}

create_vm() {
    local distro="$1"
    local vm_name="${2:-${distro}-vm}"
    check_incus || return 1

    log_info "Creating $distro Incus VM: $vm_name"

    # Check if function exists for the distro
    if declare -f "incus-${distro}-vm" >/dev/null 2>&1; then
        # Use existing function but with custom name
        local temp_name="${distro}-vm"
        "incus-${distro}-vm"

        # Rename if custom name provided
        if [[ "$vm_name" != "$temp_name" ]]; then
            log_info "Renaming VM from '$temp_name' to '$vm_name'..."
            incus move "$temp_name" "$vm_name" 2>/dev/null || true
        fi
    else
        # Fallback to direct incus launch
        case "$distro" in
        ubuntu)
            incus launch images:ubuntu/24.04 "$vm_name" --vm
            ;;
        fedora)
            incus launch images:fedora/42 "$vm_name" --vm
            ;;
        arch | archlinux)
            incus launch images:archlinux/current "$vm_name" --vm
            ;;
        tumbleweed | tw)
            incus launch images:opensuse/tumbleweed "$vm_name" --vm
            ;;
        debian)
            incus launch images:debian/12 "$vm_name" --vm
            ;;
        centos)
            incus launch images:centos/9-Stream "$vm_name" --vm
            ;;
        alpine)
            incus launch images:alpine/3.19 "$vm_name" --vm
            ;;
        nixos)
            incus launch images:nixos/24.11 "$vm_name" --vm --config security.secureboot=false
            ;;
        *)
            log_error "Unsupported distro: $distro"
            log_info "Supported distros: ubuntu, fedora, arch, tumbleweed, debian, centos, alpine, nixos"
            return 1
            ;;
        esac
    fi

    if incus info "$vm_name" >/dev/null 2>&1; then
        log_success "VM '$vm_name' created successfully"
        log_info "Starting VM..."
        incus start "$vm_name" 2>/dev/null || true
        sleep 3
        log_info "VM status:"
        incus_list_vms "$vm_name"
    else
        log_error "Failed to create VM '$vm_name'"
        return 1
    fi
}

start_vm() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)

    if [[ "$state" == "RUNNING" ]]; then
        log_warn "VM '$vm_name' is already running"
        return 0
    fi

    log_info "Starting VM '$vm_name'..."
    if incus start "$vm_name"; then
        log_success "VM '$vm_name' started"
        sleep 2
        log_info "Waiting for VM to be ready..."
        sleep 3
        incus_list_vms "$vm_name"
    else
        log_error "Failed to start VM '$vm_name'"
        return 1
    fi
}

stop_vm() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)

    if [[ "$state" != "RUNNING" ]]; then
        log_warn "VM '$vm_name' is not running"
        return 0
    fi

    log_info "Gracefully stopping VM '$vm_name'..."
    if incus stop "$vm_name"; then
        log_success "VM '$vm_name' stopped"
    else
        log_error "Failed to stop VM '$vm_name'"
        return 1
    fi
}

restart_vm() {
    local vm_name="$1"
    check_incus || return 1

    log_info "Restarting VM '$vm_name'..."
    if incus restart "$vm_name"; then
        log_success "VM '$vm_name' restarted"
        sleep 3
        incus_list_vms "$vm_name"
    else
        log_error "Failed to restart VM '$vm_name'"
        return 1
    fi
}

delete_vm() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    log_warn "This will permanently delete VM '$vm_name' and all its data!"
    read -p "Are you sure? (y/N): " -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Deletion cancelled"
        return 0
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)
    if [[ "$state" == "RUNNING" ]]; then
        log_info "Stopping VM first..."
        incus stop "$vm_name" --force
    fi

    log_info "Deleting VM '$vm_name'..."
    if incus delete "$vm_name"; then
        log_success "VM '$vm_name' deleted successfully"
    else
        log_error "Failed to delete VM '$vm_name'"
        return 1
    fi
}

connect_console() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)

    if [[ "$state" != "RUNNING" ]]; then
        log_error "VM '$vm_name' is not running"
        log_info "Start it with: $0 start $vm_name"
        return 1
    fi

    log_info "Connecting to console of VM '$vm_name'..."
    log_info "Press Ctrl+a q to exit console"
    echo
    incus console "$vm_name"
}

exec_in_vm() {
    local vm_name="$1"
    shift
    local command="$*"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)

    if [[ "$state" != "RUNNING" ]]; then
        log_error "VM '$vm_name' is not running"
        log_info "Start it with: $0 start $vm_name"
        return 1
    fi

    log_info "Executing command in VM '$vm_name': $command"
    incus exec "$vm_name" -- "$@"
}

show_vm_info() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    log_info "Detailed information for VM '$vm_name':"
    echo
    incus info "$vm_name"
}

show_vm_config() {
    local vm_name="$1"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    log_info "Configuration for VM '$vm_name':"
    echo
    incus config show "$vm_name"
}

create_snapshot() {
    local vm_name="$1"
    local snapshot_name="${2:-snap-$(date +%Y%m%d-%H%M%S)}"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    log_info "Creating snapshot '$snapshot_name' for VM '$vm_name'..."
    if incus snapshot "$vm_name" "$snapshot_name"; then
        log_success "Snapshot '$snapshot_name' created successfully"
    else
        log_error "Failed to create snapshot '$snapshot_name'"
        return 1
    fi
}

restore_snapshot() {
    local vm_name="$1"
    local snapshot_name="$2"
    check_incus || return 1

    if [[ -z "$snapshot_name" ]]; then
        log_error "Snapshot name required"
        return 1
    fi

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    log_warn "This will restore VM '$vm_name' to snapshot '$snapshot_name'"
    log_warn "All changes since the snapshot will be lost!"
    read -p "Are you sure? (y/N): " -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Restore cancelled"
        return 0
    fi

    log_info "Restoring VM '$vm_name' from snapshot '$snapshot_name'..."
    if incus restore "$vm_name" "$snapshot_name"; then
        log_success "VM '$vm_name' restored from snapshot '$snapshot_name'"
    else
        log_error "Failed to restore VM '$vm_name' from snapshot '$snapshot_name'"
        return 1
    fi
}

copy_vm() {
    local source_vm="$1"
    local dest_vm="$2"
    check_incus || return 1

    if [[ -z "$dest_vm" ]]; then
        log_error "Destination VM name required"
        return 1
    fi

    if ! incus info "$source_vm" >/dev/null 2>&1; then
        log_error "Source VM '$source_vm' not found"
        return 1
    fi

    if incus info "$dest_vm" >/dev/null 2>&1; then
        log_error "Destination VM '$dest_vm' already exists"
        return 1
    fi

    log_info "Copying VM '$source_vm' to '$dest_vm'..."
    if incus copy "$source_vm" "$dest_vm"; then
        log_success "VM '$source_vm' copied to '$dest_vm'"
    else
        log_error "Failed to copy VM '$source_vm' to '$dest_vm'"
        return 1
    fi
}

cleanup_vms() {
    check_incus || return 1

    log_info "Cleaning up stopped VMs..."

    # List stopped VMs
    local stopped_vms
    stopped_vms=$(incus_list_vms "" "--format csv --columns n,s" | grep ",STOPPED$" | cut -d',' -f1)

    if [[ -n "$stopped_vms" ]]; then
        log_info "Stopped VMs found:"
        echo "$stopped_vms"
        echo

        read -p "Remove all stopped VMs? (y/N): " -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            while IFS= read -r vm; do
                if [[ -n "$vm" ]]; then
                    log_info "Removing stopped VM: $vm"
                    incus delete "$vm" 2>/dev/null || true
                fi
            done <<<"$stopped_vms"
        fi
    else
        log_info "No stopped VMs found"
    fi

    log_success "Cleanup complete"
}

get_vm_ip() {
    local vm_name="$1"

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        return 1
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)

    if [[ "$state" != "RUNNING" ]]; then
        return 2
    fi

    # Try to get IP from incus list with network info
    local ip
    ip=$(incus list "$vm_name" --format csv --columns 4 | head -1 | cut -d',' -f1 | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)

    # If that fails, try getting it from incus info
    if [[ -z "$ip" ]]; then
        ip=$(incus info "$vm_name" | grep -A 20 "Network usage:" | grep -oE 'inet ([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1 | cut -d' ' -f2)
    fi

    # If still no IP, try alternative method
    if [[ -z "$ip" ]]; then
        ip=$(incus exec "$vm_name" -- ip -4 addr show | grep -oE 'inet ([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -v '127.0.0.1' | head -1 | cut -d' ' -f2 2>/dev/null)
    fi

    if [[ -z "$ip" ]]; then
        return 3
    fi

    echo "$ip"
    return 0
}

show_ip() {
    local vm_name="$1"
    check_incus || return 1

    if [[ -z "$vm_name" ]]; then
        log_error "VM name required"
        return 1
    fi

    local ip
    ip=$(get_vm_ip "$vm_name")
    local ret=$?

    case $ret in
    1)
        log_error "VM '$vm_name' not found"
        return 1
        ;;
    2)
        log_error "VM '$vm_name' is not running"
        log_info "Start it with: $0 start $vm_name"
        return 1
        ;;
    3)
        log_error "Could not determine IP address for VM '$vm_name'"
        log_info "VM may still be starting up. Try again in a few moments."
        return 1
        ;;
    0)
        echo "$ip"
        return 0
        ;;
    esac
}

ssh_to_vm() {
    local vm_name="$1"
    local username="${2:-}"
    check_incus || return 1

    if ! incus info "$vm_name" >/dev/null 2>&1; then
        log_error "VM '$vm_name' not found"
        return 1
    fi

    local state
    state=$(incus list "$vm_name" --format csv --columns s | head -1)

    if [[ "$state" != "RUNNING" ]]; then
        log_error "VM '$vm_name' is not running"
        log_info "Start it with: $0 start $vm_name"
        return 1
    fi

    # Auto-detect username if not provided
    if [[ -z "$username" ]]; then
        # Extract base name from VM name (remove -vm suffix if present)
        username="${vm_name%-vm}"

        # Handle special cases for common distros
        case "$username" in
        ubuntu*) username="ubuntu" ;;
        fedora*) username="fedora" ;;
        centos*) username="centos" ;;
        debian*) username="debian" ;;
        arch*) username="arch" ;;
        alpine*) username="alpine" ;;
        tumbleweed* | tw*) username="opensuse" ;;
        *)
            # Default to the VM name or common default
            if [[ "$username" =~ ^(ubuntu|fedora|centos|debian|arch|alpine|opensuse)$ ]]; then
                # Keep as is
                :
            else
                username="ubuntu" # Default fallback
            fi
            ;;
        esac

        log_info "Auto-detected username: $username (override with: $0 ssh $vm_name <username>)"
    fi

    local ip
    ip=$(get_vm_ip "$vm_name")
    local ret=$?

    case $ret in
    1)
        log_error "VM '$vm_name' not found"
        return 1
        ;;
    2)
        log_error "VM '$vm_name' is not running"
        log_info "Start it with: $0 start $vm_name"
        return 1
        ;;
    3)
        log_error "Could not determine IP address for VM '$vm_name'"
        log_info "VM may still be starting up. Try again in a few moments."
        return 1
        ;;
    0)
        log_info "Connecting to $vm_name ($ip) as $username..."
        ssh "$username@$ip"
        ;;
    esac
}

# Main command handling
if [[ $# -eq 0 ]]; then
    usage
    exit 1
fi

command="$1"
vm_name="${2:-}"

case "$command" in
install)
    install_incus
    ;;
list)
    list_vms
    ;;
status)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    vm_status "$vm_name"
    ;;
create)
    [[ -z "$vm_name" ]] && {
        log_error "Distro name required"
        usage
        exit 1
    }
    create_vm "$vm_name" "${3:-}"
    ;;
start)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    start_vm "$vm_name"
    ;;
stop)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    stop_vm "$vm_name"
    ;;
restart)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    restart_vm "$vm_name"
    ;;
delete)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    delete_vm "$vm_name"
    ;;
console)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    connect_console "$vm_name"
    ;;
exec)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    [[ $# -lt 3 ]] && {
        log_error "Command required"
        usage
        exit 1
    }
    exec_in_vm "$vm_name" "${@:3}"
    ;;
ip)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    show_ip "$vm_name"
    ;;
ssh)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    ssh_to_vm "$vm_name" "${3:-}"
    ;;
info)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    show_vm_info "$vm_name"
    ;;
config)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    show_vm_config "$vm_name"
    ;;
snapshot)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    create_snapshot "$vm_name" "${3:-}"
    ;;
restore)
    [[ -z "$vm_name" ]] && {
        log_error "VM name required"
        usage
        exit 1
    }
    [[ -z "${3:-}" ]] && {
        log_error "Snapshot name required"
        usage
        exit 1
    }
    restore_snapshot "$vm_name" "$3"
    ;;
copy)
    [[ -z "$vm_name" ]] && {
        log_error "Source VM name required"
        usage
        exit 1
    }
    [[ -z "${3:-}" ]] && {
        log_error "Destination VM name required"
        usage
        exit 1
    }
    copy_vm "$vm_name" "$3"
    ;;
cleanup)
    cleanup_vms
    ;;
--help | -h)
    usage
    ;;
*)
    log_error "Unknown command: $command"
    usage
    exit 1
    ;;
esac
