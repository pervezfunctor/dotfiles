#!/usr/bin/env bash

# shellcheck disable=SC2034
# shellcheck disable=SC1091

source "$(dirname "$0")/vt-utils"

export DISTRO_LIST_vme=("ubuntu" "fedora" "arch" "debian" "tw")

export DISTRO_LIST_vm=("ubuntu" "fedora" "debian" "arch" "alpine" "centos")

virt_check_prerequisites() {
  check_cmds virsh virt-install qemu-img wget xorriso openssl vm-create vm

  if ! systemctl is-active --quiet libvirtd; then
    warn "libvirtd service is not running, Starting..."
    sudo systemctl start libvirtd
    sleep 1

    if ! systemctl is-active --quiet libvirtd; then
      die "Failed to start libvirtd service"
    else
      slog "libvirtd service started"
    fi
  fi

  if ! groups | grep -q libvirt; then
    fail "User not in libvirt group. You may need sudo for virsh commands"
    fail "Add user to group: sudo usermod -a -G libvirt \$USER"
    exit 1
  fi
}

get_vm_list() {
  virsh --connect qemu:///system list --all | awk 'NR>2 && $0 !~ /^[-[:space:]]*$/ {print $2}'
}

vm_list() {
  slog "Listing all VMs..."
  echo
  if has_cmd virsh; then
    virsh list --all
  else
    die "virsh command not found. Please install virtualization tools first."
  fi
}

vm_exists() {
  virsh dominfo "$1" &>/dev/null
}

vme_exists() {
  vm_exists "$1"
}

vm_check_exists() {
  local vm_name="$1"

  vm_exists "$vm_name" && return 0

  die "VM '$vm_name' not found"
}

vm_running() {
  vm_exists "$1" || return 1
  local vm_name="$1"
  local state
  state=$(vm_state "$vm_name")
  [[ "$state" == "running" ]]
}

vme_running() {
  vm_running "$1"
}

vm_check_running() {
  local vm="$1"
  vm_check_exists "$vm"

  vm_running "$vm" || {
    die "VM '$vm' is not running"
  }
}

vm_state() {
  local vm_name="$1"
  virsh domstate "$vm_name"
}

vm_ip() {
  local ip
  ip=$(virsh --connect qemu:///system domifaddr --source agent "$1" 2>/dev/null |
    awk '/ipv4/ && $1 !~ /^lo$/ {print $4}' |
    head -n1 |
    cut -d'/' -f1)

  if [[ -n "$ip" ]]; then
    printf '%s\n' "$ip"
    return 0
  fi

  return 1
}

vme_ip() {
  vm_ip "$1"
}

vm_ssh() {
  local vm_name="$1"
  local username="${2:-}"
  vm_check_exists "$vm_name" || return 1

  if [[ -z "$vm_name" ]]; then
    fail "VM name not provided. Usage: vm ssh <vm_name> [username]"
    return 1
  fi

  if [[ -z "$username" ]]; then
    fail "Username not provided. Usage: vm ssh <vm_name> [username]"
    return 1
  fi

  local state
  state=$(virsh domstate "$vm_name")

  if [[ "$state" != "running" ]]; then
    fail "VM '$vm_name' is not running"
    slog "Start it with: $0 start $vm_name"
    return 1
  fi

  local ip
  ip=$(vm_ip "$vm_name")

  slog "Connecting to $vm_name ($ip) as $username..."
  ssh "$username@$ip"
}

libvirt_net_defined() {
  virsh net-info "$1" >/dev/null 2>&1
}

libvirt_default_net_defined() {
  libvirt_net_defined "default"
}

define_default_net() {
  local net_name=${1:-default}
  if virsh net-info "$net_name" >/dev/null 2>&1; then
    echo "Network '$net_name' is already defined."
    return 0
  else
    echo "Network '$net_name' is not defined. Attempting to define it..."
  fi

  local candidates=(
    /usr/share/libvirt/networks/default.xml
    /usr/local/share/libvirt/networks/default.xml
    /var/lib/libvirt/network/default.xml
    /etc/libvirt/qemu/networks/default.xml
  )

  local xml
  for xml in "${candidates[@]}"; do
    if [[ -r "$xml" ]]; then
      echo "Found default network XML at $xml"
      virsh net-define "$xml"
      return $?
    fi
  done

  echo "Dumping default network XML to /tmp/default.xml to define it..."
  rm -f /tmp/default.xml
  virsh net-dumpxml default >/tmp/default.xml
  virsh net-define /tmp/default.xml
}

undefine_default_net() {
  local net_name=${1:-default}
  if virsh net-info "$net_name" >/dev/null 2>&1; then
    echo "Network '$net_name' is defined. Attempting to undefine it..."
    virsh net-destroy "$net_name"
    virsh net-undefine "$net_name"
  else
    echo "Network '$net_name' is not defined."
    return 0
  fi
}

ensure_libvirt_default_net() {
  local net_name=${1:default}
  define_default_net "$net_name" || {
    echo "Failed to define network '$net_name'" >&2
    return 1
  }

  local state
  state=$(virsh net-info "$net_name" | awk '/State:/ {print $2}')
  if [[ "$state" != "active" ]]; then
    echo "Starting network '$net_name'..."
    virsh net-start "$net_name" || return 1
  else
    echo "Network '$net_name' is already running."
  fi

  local autostart
  autostart=$(virsh net-info "$net_name" | awk '/Autostart:/ {print $2}')
  if [[ "$autostart" != "yes" ]]; then
    echo "Enabling autostart for '$net_name'..."
    virsh net-autostart "$net_name"
  fi
}

LIBVIRT_ISO_POOL_PATH="/srv/libvirt/images/iso"
LIBVIRT_ISO_POOL_NAME="iso-pool"

libvirt_iso_pool_create() {
  if virsh pool-info "$LIBVIRT_ISO_POOL_NAME" >/dev/null 2>&1; then
    return 0
  fi

  echo "Creating ISO pool $LIBVIRT_ISO_POOL_NAME at $LIBVIRT_ISO_POOL_PATH..."
  sudo mkdir -p "$LIBVIRT_ISO_POOL_PATH"
  sudo virsh pool-define-as "$LIBVIRT_ISO_POOL_NAME" dir --target "$LIBVIRT_ISO_POOL_PATH"
  sudo virsh pool-start "$LIBVIRT_ISO_POOL_NAME"
  sudo virsh pool-autostart "$LIBVIRT_ISO_POOL_NAME"
}

configure_arch() {
  if [[ -n "$RELEASE" && "$RELEASE" != "latest" ]]; then
    warn "Arch Linux only supports latest release. Ignoring RELEASE='$RELEASE'"
  fi
  RELEASE="latest"
  IMG_URL="https://geo.mirror.pkgbuild.com/images/latest/Arch-Linux-x86_64-cloudimg.qcow2"
  CHECKSUM_URL="https://geo.mirror.pkgbuild.com/images/latest/Arch-Linux-x86_64-cloudimg.qcow2.SHA256"
  OS_VARIANT="archlinux"
}

configure_ubuntu() {
  RELEASE=${RELEASE:="plucky"}
  IMG_URL="https://cloud-images.ubuntu.com/${RELEASE}/current/${RELEASE}-server-cloudimg-amd64.img"
  CHECKSUM_URL="https://cloud-images.ubuntu.com/questing/current/SHA256SUMS"
  OS_VARIANT="ubuntu25.10"
}

configure_debian() {
  RELEASE=${RELEASE:="trixie"}

  IMG_URL="https://cloud.debian.org/images/cloud/trixie/latest/debian-13-generic-amd64.qcow2"
  CHECKSUM_URL="https://cloud.debian.org/images/cloud/trixie/latest/SHA512SUMS"
  OS_VARIANT="debian13"
}

configure_fedora() {
  if [[ -z "$RELEASE" && "$RELEASE" != "43" ]]; then
    warn "Fedora only supports release 43. Installing Fedora 43."
  fi
  RELEASE=43
  IMG_URL="https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/Cloud/x86_64/images/Fedora-Cloud-Base-Generic-43-1.6.x86_64.qcow2"
  CHECKSUM_URL="https://mirror.hoster.kz/fedora/fedora/linux/releases/${RELEASE}/Cloud/x86_64/images/Fedora-Cloud-43-1.6-x86_64-CHECKSUM"
  OS_VARIANT="fedora42"
}

configure_tw() {
  if [[ -n "$RELEASE" && "$RELEASE" != "latest" ]]; then
    warn "Tumbleweed only supports latest release. Ignoring RELEASE='$RELEASE'"
  fi
  RELEASE="latest"
  IMG_URL="https://download.opensuse.org/tumbleweed/appliances/openSUSE-Tumbleweed-Minimal-VM.x86_64-Cloud.qcow2"
  CHECKSUM_URL="https://download.opensuse.org/tumbleweed/appliances/openSUSE-Tumbleweed-Minimal-VM.x86_64-Cloud.qcow2.sha256"
  OS_VARIANT="opensusetumbleweed"
}

configure_centos() {
  RELEASE=${RELEASE:-"9"}
  IMG_URL="https://cloud.centos.org/centos/${RELEASE}-stream/x86_64/images/CentOS-Stream-GenericCloud-${RELEASE}-latest.x86_64.qcow2"
  CHECKSUM_URL="https://cloud.centos.org/centos/${RELEASE}-stream/x86_64/images/CentOS-Stream-GenericCloud-${RELEASE}-latest.x86_64.qcow2.SHA256SUM"
  OS_VARIANT="centos-stream9"
}

configure_rocky() {
  RELEASE=${RELEASE:-"9"}
  IMG_URL="https://download.rockylinux.org/pub/rocky/${RELEASE}/images/x86_64/Rocky-${RELEASE}-GenericCloud.latest.x86_64.qcow2"
  CHECKSUM_URL="https://download.rockylinux.org/pub/rocky/${RELEASE}/images/x86_64/CHECKSUM"
  OS_VARIANT="rocky-linux-9"
}

configure_alpine() {
  RELEASE=${RELEASE:-"3.22.2"}
  IMG_URL="https://dl-cdn.alpinelinux.org/alpine/v${RELEASE}/releases/cloud/generic_alpine-${RELEASE}-x86_64-uefi-cloudinit-r0.qcow2"
  OS_VARIANT="alpinelinux3.22"
  CHECKSUM_URL="https://dl-cdn.alpinelinux.org/alpine/${RELEASE}/releases/cloud/generic_alpine-${RELEASE}-x86_64-uefi-cloudinit-r0.qcow2.sha512"
}

configure_distribution() {
  local DISTRO="${1:-$DISTRO}"

  case "$DISTRO" in
  arch)
    configure_arch
    ;;
  ubuntu)
    configure_ubuntu
    ;;
  debian)
    configure_debian
    ;;
  fedora)
    configure_fedora
    ;;
  tw | tumbleweed)
    configure_tw
    ;;
  centos)
    configure_centos
    ;;
  rocky)
    configure_rocky
    ;;
  alpine)
    configure_alpine
    ;;
  *)
    fail "Unknown distribution: $DISTRO"
    fail "Supported distributions: arch, ubuntu, debian, fedora, tumbleweed, centos, rocky, alpine"
    usage
    exit 1
    ;;
  esac

  BASE_IMAGE="${BASE_IMG_DIR}/$(basename "$IMG_URL")"
  CHECKSUM_FILE="${BASE_IMAGE}.checksum"
}

generate_cloud_init() {
  slog "Generating cloud-init configuration..."
  PASSWORD_HASH=$(openssl passwd -6 "$PASSWORD")

  local cloud_init_dir
  cloud_init_dir=$(mktemp -d)

  USER_DATA="${cloud_init_dir}/user-data"
  META_DATA="${cloud_init_dir}/meta-data"

  local pub_key
  pub_key=$(cat "$SSH_KEY_PATH")

  local openssh_pkg
  case "$DISTRO" in
  arch | tw | tumbleweed)
    openssh_pkg="openssh"
    ;;
  *)
    openssh_pkg="openssh-server"
    ;;
  esac

  local -a packages=(
    "qemu-guest-agent"
    "bash"
    "curl"
    "$openssh_pkg"
  )

  local -a runcmd_lines
  if [[ "$DISTRO" == "alpine" ]]; then
    runcmd_lines=(
      "rc-update add qemu-guest-agent default || true"
      "service qemu-guest-agent start || true"
      "rc-update add sshd default || true"
      "service sshd start || true"
    )
  else
    runcmd_lines=(
      "systemctl enable --now qemu-guest-agent || true"
      "systemctl enable --now ssh || systemctl enable --now sshd || true"
    )
  fi

  local sudo_groups
  if [[ "$DISTRO" == "ubuntu" || "$DISTRO" == "debian" ]]; then
    sudo_groups="sudo"
  else
    sudo_groups="wheel"
  fi

  cat >"${USER_DATA}" <<EOF
#cloud-config
hostname: $VM_NAME
manage_etc_hosts: true

users:
  - name: $USERNAME
    groups:
      - $sudo_groups
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    lock_passwd: false
    passwd: $PASSWORD_HASH
    ssh_authorized_keys:
      - $pub_key

package_update: true

packages:
$(for p in "${packages[@]}"; do printf "  - %s\n" "$p"; done)

runcmd:
$(printf "  - %s\n" "${runcmd_lines[@]}")
EOF

  cat >"${META_DATA}" <<EOF
instance-id: ${VM_NAME}-$(date +%s)
local-hostname: $VM_NAME
EOF

  success "Cloud-init configuration generated"
}

verify_checksum() {
  local img="$1"
  local sumfile="$2"
  local base_img
  base_img="$(basename "$img")"

  info "Verifying checksum for: $base_img"

  # Remove PGP signature from the checksum file
  grep -vE '^(-----BEGIN|-----END)' "$sumfile" >"${sumfile}.clean"
  mv "${sumfile}.clean" "$sumfile"

  local hash=""

  # 1. Fedora/Centos style: SHA256 (filename) = hash
  if grep -q "SHA256 (${base_img}) =" "$sumfile"; then
    hash="$(grep "SHA256 (${base_img}) =" "$sumfile" | awk -F'= ' '{print $2}')"
  # 2. GNU-style(ubuntu): <hash> [*]filename
  elif
    hash="$(grep -E "[[:space:]]\*?${base_img}$" "$sumfile" | awk '{print $1}' 2>/dev/null)"
    [[ -n "$hash" ]]
  then
    :
  # 3. Raw Alpine-style: single-line hash only
  elif [[ $(wc -l <"$sumfile") -eq 1 && $(wc -w <"$sumfile") -eq 1 ]]; then
    hash="$(cat "$sumfile")"
  # 4. No supported format matched
  else
    fail "Unsupported checksum format for $base_img"
    sleep 2
    warn "Skipping checksum verification..."
  fi

  case "${#hash}" in
  64)
    echo "${hash}  ${img}" | sha256sum -c - || die "SHA256 checksum mismatch"
    ;;
  128)
    echo "${hash}  ${img}" | sha512sum -c - || die "SHA512 checksum mismatch"
    ;;
  *)
    die "Unknown checksum length ${#hash}"
    ;;
  esac

  info "Checksum OK"
}
