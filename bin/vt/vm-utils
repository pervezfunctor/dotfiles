#!/usr/bin/env bash

# shellcheck disable=SC1091
source "$(dirname "$0")/vt-utils"

export DISTRO_LIST_vme=("ubuntu" "fedora" "arch" "debian" "tw")

export vm_DISTRO_LIST=("ubuntu" "fedora" "debian" "arch" "alpine" "centos")

export DISTRO_LIST_vmu=("debian" "ubuntu" "fedora" "arch" "tw")

virt_check_prerequisites() {
  local missing_tools=()
  for tool in virsh virt-install qemu-img wget xorriso openssl; do
    if ! has_cmd "$tool"; then
      missing_tools+=("$tool")
    fi
  done

  if [[ ${#missing_tools[@]} -gt 0 ]]; then
    fail "Missing required tools: ${missing_tools[*]}"
    slog "Install with: vm install"
    exit 1
  fi

  if ! systemctl is-active --quiet libvirtd; then
    warn "libvirtd service is not running, Starting..."
    sudo systemctl start libvirtd
    sleep 1

    if ! systemctl is-active --quiet libvirtd; then
      fail "Failed to start libvirtd service"
      exit 1
    else
      slog "libvirtd service started"
    fi
  fi

  if ! groups | grep -q libvirt; then
    fail "User not in libvirt group. You may need sudo for virsh commands"
    fail "Add user to group: sudo usermod -a -G libvirt \$USER"
    exit 1
  fi
}

vm_check_prerequisites() {
  virt_check_prerequisites

  if ! has_cmd vm-create; then
    fail "vm-create is not in PATH."
    exit 1
  fi

  if ! has_cmd vm; then
    fail "vm is not in PATH."
    exit 1
  fi
}

get_vm_list() {
  virsh --connect qemu:///system list --all | awk 'NR>2 && $0 !~ /^[-[:space:]]*$/ {print $2}'
}

vm_list() {
  slog "Listing all VMs..."
  echo
  if has_cmd virsh; then
    virsh list --all
  else
    fail "virsh command not found. Please install virtualization tools first."
    slog "You can install them with: vm install"
    return 1
  fi
}

vm_exists() {
  virsh dominfo "$1" &>/dev/null
}

vm_check_exists() {
  local vm_name="$1"

  vm_exists "$vm_name" && return 0

  fail "VM '$vm_name' not found"
  return 1
}

vm_running() {
  vm_exists "$1" || return 1
  local vm_name="$1"
  local state
  state=$(vm_state "$vm_name")
  [[ "$state" == "running" ]]
}

vm_check_running() {
  local vm="$1"
  vm_check_exists "$vm" || exit 1

  vm_running "$vm"
}

vm_state() {
  local vm_name="$1"
  virsh domstate "$vm_name"
}

vm_ip() {
  local ip
  ip=$(virsh --connect qemu:///system domifaddr --source agent "$1" 2>/dev/null |
    awk '/ipv4/ && $1 !~ /^lo$/ {print $4}' |
    head -n1 |
    cut -d'/' -f1)

  if [[ -n "$ip" ]]; then
    printf '%s\n' "$ip"
    return 0
  fi

  return 1
}

vm_ssh() {
  local vm_name="$1"
  local username="${2:-}"
  vm_check_exists "$vm_name" || return 1

  if [[ -z "$vm_name" ]]; then
    fail "VM name not provided. Usage: vm ssh <vm_name> [username]"
    return 1
  fi

  if [[ -z "$username" ]]; then
    fail "Username not provided. Usage: vm ssh <vm_name> [username]"
    return 1
  fi

  local state
  state=$(virsh domstate "$vm_name")

  if [[ "$state" != "running" ]]; then
    fail "VM '$vm_name' is not running"
    slog "Start it with: $0 start $vm_name"
    return 1
  fi

  local ip
  ip=$(vm_ip "$vm_name")

  slog "Connecting to $vm_name ($ip) as $username..."
  ssh "$username@$ip"
}

libvirt_net_defined() {
  virsh net-info "$1" >/dev/null 2>&1
}

libvirt_default_net_defined() {
  libvirt_net_defined "default"
}

define_default_net() {
  local net_name=${1:-default}
  if virsh net-info "$net_name" >/dev/null 2>&1; then
    echo "Network '$net_name' is already defined."
    return 0
  else
    echo "Network '$net_name' is not defined. Attempting to define it..."
  fi

  local candidates=(
    /usr/share/libvirt/networks/default.xml
    /usr/local/share/libvirt/networks/default.xml
    /var/lib/libvirt/network/default.xml
    /etc/libvirt/qemu/networks/default.xml
  )

  local xml
  for xml in "${candidates[@]}"; do
    if [[ -r "$xml" ]]; then
      echo "Found default network XML at $xml"
      virsh net-define "$xml"
      return $?
    fi
  done

  echo "Dumping default network XML to /tmp/default.xml to define it..."
  rm -f /tmp/default.xml
  virsh net-dumpxml default >/tmp/default.xml
  virsh net-define /tmp/default.xml
}

undefine_default_net() {
  local net_name=${1:-default}
  if virsh net-info "$net_name" >/dev/null 2>&1; then
    echo "Network '$net_name' is defined. Attempting to undefine it..."
    virsh net-destroy "$net_name"
    virsh net-undefine "$net_name"
  else
    echo "Network '$net_name' is not defined."
    return 0
  fi
}

ensure_libvirt_default_net() {
  local net_name=${1:default}
  define_default_net "$net_name" || {
    echo "Failed to define network '$net_name'" >&2
    return 1
  }

  local state
  state=$(virsh net-info "$net_name" | awk '/State:/ {print $2}')
  if [[ "$state" != "active" ]]; then
    echo "Starting network '$net_name'..."
    virsh net-start "$net_name" || return 1
  else
    echo "Network '$net_name' is already running."
  fi

  local autostart
  autostart=$(virsh net-info "$net_name" | awk '/Autostart:/ {print $2}')
  if [[ "$autostart" != "yes" ]]; then
    echo "Enabling autostart for '$net_name'..."
    virsh net-autostart "$net_name"
  fi
}

LIBVIRT_ISO_POOL_PATH="/srv/libvirt/images/iso"
LIBVIRT_ISO_POOL_NAME="iso-pool"

libvirt_iso_pool_create() {
  if virsh pool-info "$LIBVIRT_ISO_POOL_NAME" >/dev/null 2>&1; then
    return 0
  fi

  echo "Creating ISO pool $LIBVIRT_ISO_POOL_NAME at $LIBVIRT_ISO_POOL_PATH..."
  sudo mkdir -p "$LIBVIRT_ISO_POOL_PATH"
  sudo virsh pool-define-as "$LIBVIRT_ISO_POOL_NAME" dir --target "$LIBVIRT_ISO_POOL_PATH"
  sudo virsh pool-start "$LIBVIRT_ISO_POOL_NAME"
  sudo virsh pool-autostart "$LIBVIRT_ISO_POOL_NAME"
}

wait_for_ip() {
  local vm_name="$1"

  printf '\033[1;36mðŸ” Wait for IP address? (Y/n):\033[0m ' >&2
  read -t 5 -r response || response="y"

  case "$response" in
  n | N)
    slog "Skipping IP wait. You can get the IP later with: virsh domifaddr $vm_name --source agent"
    return 1
    ;;
  *)
    if wait_until 30 2 bash -c "virsh domstate $vm_name | grep -q running"; then
      slog "VM is running"
    else
      return 1
    fi

    if wait_until 60 2 vm_ip "$vm_name" >/dev/null; then
      slog "VM has IP address"
      sleep 1
    else
      return 1
    fi

    return 0
    ;;
  esac
}
