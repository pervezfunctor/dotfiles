#!/usr/bin/env bash

# shellcheck disable=SC1091

set -euo pipefail -o errtrace

source "$(dirname "$0")/vm-utils"

cmd_vme() {
  virsh --connect qemu:///system "$@"
}

check_prerequisites() {
  for cmd in virsh vme-create trash; do
    if ! has_cmd "$cmd"; then
      fail "⚠️  Warning: Required command '$cmd' is not available."
      # exit 1
    fi
  done
  has_cmd virt-cat || fail "⚠️  virt-cat not available, some commands won't work"
}

usage() {
  cat <<EOF
Usage: $0 <command> [vm-name...]

Manage VMs created with vme-create script. These are user-mode VMs, not full libvirt VMs.

COMMANDS:
    list                List all VMs
    create  ARGS        Create a new VM, with same ARGS as vme-create
    create-all ARGS     Create multiple VMs, see vme-create-multi --help for options
    autostart <vm-name> Set VM to start on boot
    start [vm-name...]  Start VM(s) - if no names provided, select from list
    shutdown [vm-name...] Gracefully stop VM(s) - if no names provided, select from list
    restart [vm-name...] Restart VM(s) - if no names provided, select from list
    kill [vm-name...]   Force stop VM(s) - if no names provided, select from list
    delete [vm-name...] Delete VM(s) completely - if no names provided, select from list
    console <vm-name>   Connect to VM console
    ip <vm-name>        Show VM IP address (short form)
    is-running <vm-name> Check if VM is running
    info <vm-name>      Show VM status and info
    logs <vm-name>      Show cloud-init logs
    disk <vm-name>      Show VM disk usage
    ssh <vm-name> [user] SSH into VM (auto-detects user if omitted)
    exec <vm-name> <command> Execute command in VM
    cmd <virsh-args>    Run virsh command with qemu:///system connection
    net <command>       Manage libvirt virtual networks (see 'vm net' command)
    start-libvirt       Start the libvirtd service

EXAMPLES:
    $0 list                    # List all VMs
    $0 ip debian               # Show IP address of 'debian' VM (short form)
    $0 is-running debian       # Check if 'debian' VM is running
    $0 status debian           # Show status of 'debian' VM
    $0 create debian           # Create debian VM
    $0 start debian            # Start 'debian' VM
    $0 start debian fedora     # Start multiple VMs
    $0 start                   # Select VMs to start from menu
    $0 delete old-vm           # Delete 'old-vm' completely
    $0 delete ubuntu fedora    # Delete multiple VMs
    $0 ssh debian              # SSH into 'debian' VM
    $0 exec debian "ls -la"    # Run command in 'debian' VM
EOF
}

disk_vme() {
  virsh --connect qemu:///system domblklist "$1"
}

status_vme() {
  virsh --connect qemu:///system dominfo "$1"
}

autostart_vme() {
  virsh --connect qemu:///system autostart "$1"
}

start_vme() {
  virsh --connect qemu:///system start "$1"
}

stop_vme() {
  virsh --connect qemu:///system shutdown "$1"
}

restart_vme() {
  virsh --connect qemu:///system reboot "$1"
}

force_stop_vme() {
  virsh --connect qemu:///system destroy "$1"
}

delete_vme() {
  local vda
  vda=$(virsh --connect qemu:///system domblklist "$1" | grep vda | awk '{print $2}')

  virsh --connect qemu:///system destroy "$1" >/dev/null 2>&1 || true
  virsh --connect qemu:///system undefine "$1" >/dev/null 2>&1 || true

  if [[ -n "$vda" ]]; then
    dir=$(dirname "$vda")

    slog "Found vm directory: $dir"
    read -p "Delete dir? (y/N): " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      warn "Deleting $dir"
      sudo rm -rf "$dir"
    fi
  fi
}

logs_vme() {
  sudo virt-cat -d "$1" /var/log/cloud-init.log
}

console_vme() {
  virsh --connect qemu:///system console "$1"
}

is-running_vme() {
  vm_exists "$1" && vm_state "$1" | grep -q "^running$"
}

list_vme_all() {
  virsh --connect qemu:///system list --all
}

list_vme() {
  virsh --connect qemu:///system list --all | awk 'NR>2 && $0 !~ /^[-[:space:]]*$/ {print $2}'
}

resolve_vm_name() {
  local name="$1"
  if [[ -n "$name" ]]; then
    printf '%s\n' "$name"
    return 0
  fi

  local vms selected rc
  if ! vms=$(list_vme); then
    fail "Failed to list virtual machines" >&2
    return 1
  fi

  if [[ -z "$vms" ]]; then
    fail "No virtual machines found" >&2
    return 1
  fi

  selected=$(select-one 'VM > ' "$vms")
  rc=$?
  if [[ $rc -ne 0 || -z "$selected" ]]; then
    if [[ $rc -eq 127 ]]; then
      fail "fzf is not installed or not in PATH" >&2
    else
      fail "Cancelled" >&2
    fi
    return 1
  fi

  printf '%s\n' "$selected"
}

detect_user_for_vm() {
  # Heuristic username detection by VM name; default to ubuntu
  # Usage: detect_user_for_vm <vmname> -> echoes username
  local name lower
  name="$1"
  lower="${name,,}"
  if [[ "$lower" == *coreos* ]]; then
    printf '%s\n' coreos
  elif [[ "$lower" == *fedora* ]]; then
    printf '%s\n' fedora
  elif [[ "$lower" == *debian* || "$lower" == *bookworm* || "$lower" == *bullseye* || "$lower" == *trixie* ]]; then
    printf '%s\n' debian
  elif [[ "$lower" == *arch* ]]; then
    printf '%s\n' arch
  else
    printf '%s\n' ubuntu
  fi
}

ssh_vme() {
  local vm user ip
  vm="$1"
  user="${2:-$USER}"

  if ! vm_check_running "$vm"; then
    fail "VM does not exist or is not running"
    exit 1
  fi

  if ! ip=$(vm_ip "$vm"); then
    fail "Could not determine IP for VM '$vm'"
    exit 1
  fi

  exec ssh -o ConnectTimeout="15" -o ConnectionAttempts=1 "${user}@${ip}"
}

exec_vme() {
  local vm="$1"
  shift
  local user="${2:-$USER}"
  local command="$*"

  if ! vm_check_running "$vm"; then
    fail "VM does not exist or is not running"
    exit 1
  fi

  if [[ -z "$command" ]]; then
    fail "Error: Command required for exec"
    info "Usage: $0 exec <vm-name> <command>"
    exit 1
  fi

  local ip
  if ! ip=$(vm_ip "$vm"); then
    fail "Could not determine IP for VM '$vm'"
    exit 1
  fi

  ssh \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -o ConnectTimeout="15" \
    -o ConnectionAttempts=1 \
    -o LogLevel=ERROR \
    "${user}@${ip}" \
    "$command"
}

net_usage() {
  cat <<EOF
Usage: $0 net <command> [network-name]
EOF
  echo
  cat <<EOF
Manage libvirt virtual networks.
EOF
  echo
  cat <<EOFCOMMANDS
    list                List all virtual networks
    info <network-name> Show details of a specific network
    start <network-name> Start a specific network
    auto-start <network-name> Set a network to start on boot
    stop <network-name> Stop a specific network
    delete <network-name> Delete a specific network
EOFCOMMANDS
  echo
  cat <<EOFEXAMPLES
EXAMPLES:
    $0 net list                    # List all virtual networks
    $0 net info default            # Show details of 'default' network
    $0 net start default           # Start 'default' network
    $0 net delete old-network      # Delete 'old-network'
EOFEXAMPLES
}

net_vme() {
  local command
  command="$1"
  shift

  case "$command" in
  ls | list)
    virsh --connect qemu:///system net-list --all
    ;;
  info)
    virsh --connect qemu:///system net-info "$@"
    ;;
  start)
    virsh --connect qemu:///system net-start "$@"
    ;;
  auto-start)
    virsh --connect qemu:///system net-autostart "$@"
    ;;
  stop)
    virsh --connect qemu:///system net-destroy "$@"
    ;;
  rm | delete)
    virsh --connect qemu:///system net-destroy "$@" >/dev/null 2>&1 || true
    virsh --connect qemu:///system net-undefine "$@"
    ;;
  *)
    fail "Unknown net command: $1"
    net_usage
    exit 1
    ;;
  esac
}

ip_vme() {
  vm_ip "$@"
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  check_prerequisites

  local command vm_name
  command="$1"
  vm_name="${2:-}"
  shift

  case "$command" in
  start-libvirt)
    sudo systemctl start libvirtd
    ;;
  list | ls)
    list_vme_all
    ;;
  cmd)
    cmd_vme "$@"
    ;;
  disk)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    disk_vme "$target"
    ;;
  info | status)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    status_vme "$target"
    ;;
  create | new)
    vme-create "$@"
    ;;
  create-all)
    vme-create-multi "$@"
    ;;
  autostart)
    handle_multiple_arguments vme autostart "$@"
    ;;
  start | boot)
    handle_multiple_arguments vme start "$@"
    ;;
  stop | shutdown)
    handle_multiple_arguments vme stop "$@"
    ;;
  restart | reboot)
    handle_multiple_arguments vme restart "$@"
    ;;
  destroy | kill | force-stop)
    handle_multiple_arguments vme force_stop "$@"
    ;;
  delete | rm)
    handle_multiple_arguments vme delete "$@"
    ;;
  console)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    console_vme "$target" "${@:2}"
    ;;
  ip)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    ip_vme "$target" "${@:2}"
    ;;
  is-running)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    is-running_vme "$target" "${@:2}"
    ;;
  net)
    net_vme "$@"
    ;;
  logs)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    logs_vme "$target" "${@:2}"
    ;;
  ssh)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    ssh_vme "$target" "${@:2}"
    ;;
  exec)
    {
      target=$(resolve_vm_name "$vm_name")
    } || exit 1
    exec_vme "$target" "${@:2}"
    ;;
  --help | -h)
    usage
    ;;
  *)
    fail "Unknown command: $command"
    usage
    ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
