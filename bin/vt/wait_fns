#!/usr/bin/env bash

wait_until_usage() {
  cat <<EOF
wait_until - Wait for a predicate to return zero exit code

USAGE:
    wait_until <timeout_seconds> <interval_seconds> <command> [args...]

ARGUMENTS:
    timeout_seconds    Maximum time to wait before giving up
    interval_seconds   Time to wait between command attempts
    command            The command or function to execute
    args               Additional arguments for the command

RETURN VALUES:
    0                  Success (predicate returned zero exit code within timeout)
    1                  Failure (timeout exceeded or invalid parameters)

EXAMPLE:
    wait_until 30 2 systemctl is-active sshd

DESCRIPTION:
    Executes the specified command repeatedly until it returns a zero exit code or the timeout is reached. The command is executed at the specified interval until either the predicate returns zero or the maximum number of attempts is exceeded.
EOF
}

wait_for_usage() {
  cat <<EOF
  wait_for - Wait until command output contains expected text

  USAGE:
    wait_for <timeout_seconds> <interval_seconds> <expected_text> <command> [args...]

  ARGUMENTS:
    timeout_seconds    Maximum time to wait before giving up
    interval_seconds   Time to wait between command attempts
    expected_text      Text to search for in command output
    command            The command or function to execute
    args               Additional arguments for the command

  RETURN VALUES:
    0                  Success (expected text found within timeout)
    1                  Failure (timeout exceeded or invalid parameters)

  EXAMPLE:
    wait_for 30 2 "ready" curl http://localhost:8080/health

  DESCRIPTION:
    Executes the specified command repeatedly until its output contains the expected text or the timeout is reached. The command is executed at the specified interval until either the expected text is found in the output or the maximum number of attempts is exceeded.
EOF
}

is_positive_int() {
  [[ "$1" =~ ^[1-9][0-9]*$ ]]
}

is_negative_int() {
  [[ "$1" =~ ^-[1-9][0-9]*$ ]]
}

# Internal: core polling loop
# Arguments:
#   $1 = timeout seconds
#   $2 = interval seconds
#   $3 = mode: "exit" or "output"
#   $4 = expected output (only for mode=output; empty for mode=exit)
#   $@ = predicate command
_wait_core() {
  local timeout="$1"
  local interval="$2"
  local mode="$3"
  local expected="$4"
  shift 4
  local predicate_cmd=("$@")

  local start_time=$SECONDS

  while true; do
    local output=""
    if [[ "$mode" == "output" ]]; then
      output=$(timeout "${interval}s" "${predicate_cmd[@]}" 2>/dev/null)
      if [[ $? -eq 0 && "$output" == *"$expected"* ]]; then
        return 0
      fi
    else
      if timeout "${interval}s" "${predicate_cmd[@]}" >/dev/null 2>&1; then
        return 0
      fi
    fi

    local elapsed=$((SECONDS - start_time))
    if ((elapsed >= timeout)); then
      return 1
    fi

    local remaining=$((timeout - elapsed))
    local sleep_time=$interval
    ((sleep_time > remaining)) && sleep_time=$remaining
    sleep "$sleep_time"
  done
}

wait_until() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    wait_until_usage
    return 0
  fi

  if [[ $# -lt 3 ]]; then
    echo "Error: invalid number of arguments" >&2
    wait_until_usage
    return 1
  fi

  local timeout="$1"
  local interval="$2"
  shift 2

  is_positive_int "$timeout" || {
    echo "Error: timeout must be positive" >&2
    return 1
  }
  is_positive_int "$interval" || {
    echo "Error: interval must be positive" >&2
    return 1
  }

  _wait_core "$timeout" "$interval" "exit" "" "$@"
}

wait_for() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    wait_for_usage
    return 0
  fi

  if [[ $# -lt 4 ]]; then
    echo "Error: invalid number of arguments" >&2
    wait_for_usage
    return 1
  fi

  local timeout="$1"
  local interval="$2"
  local expected="$3"
  shift 3

  is_positive_int "$timeout" || {
    echo "Error: timeout must be positive" >&2
    return 1
  }
  is_positive_int "$interval" || {
    echo "Error: interval must be positive" >&2
    return 1
  }
  [[ -n "$expected" ]] || {
    echo "Error: expected text cannot be empty" >&2
    return 1
  }

  _wait_core "$timeout" "$interval" "output" "$expected" "$@"
}
