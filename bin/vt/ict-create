#!/usr/bin/env bash

set -euo pipefail -o errtrace

# shellcheck disable=SC1091
source "$(dirname "$0")/incus-utils"

# Default values
unset CONTAINER_NAME
unset DISTRO
unset RELEASE
unset USERNAME
unset PASSWORD
unset SSH_KEY_PATH
unset IMAGE_URL

VCPUS="2"
MEMORY_MB="2048"
PRIVILEGED="false"

usage() {
  cat <<EOF
Usage: $0 --distro DISTRO [OPTIONS]

Create Incus LXC containers with cloud-init and SSH access.

REQUIRED:
    --distro DISTRO         Distribution (ubuntu, fedora, arch, debian, centos, tumbleweed, alpine)

OPTIONS:
    --name NAME             Container name (default: distro name)

    --username USER         Username for container (default: distro default)
    --password PASS         User password (default: container name)
    --ssh-key PATH          SSH public key path (default: auto-detect/generate)

    --privileged            Create privileged container (default: false)

    --vcpus NUM             Number of vCPUs (default: 2)
    --memory MB             RAM in MB (default: 2048)
    --release RELEASE       Distribution release (default: latest)

    --help, -h              Show this help

EXAMPLES:
    $0 --distro ubuntu
    $0 --distro fedora --name my-fedora --vcpus 4 --memory 2048
    $0 --distro debian --username admin --password mypass
    $0 --distro arch --release current --privileged
    $0 --distro tw --name opensuse-container --vcpus 2 --memory 2048

SUPPORTED DISTRIBUTIONS:
    ubuntu      - Ubuntu (questing/25.10) or specified release
    fedora      - Fedora (latest) or specified release
    arch        - Arch Linux (current)
    debian      - Debian (13/trixie) or specified release
    centos      - CentOS Stream (9) or specified release
    tw          - openSUSE Tumbleweed (rolling release)
    alpine      - Alpine Linux (latest) or specified release

NOTE: LXC containers are lightweight and share the host kernel.
      They start faster and use fewer resources than VMs.

EOF
}

show_configuration() {
  echo
  printf '\033[1;36mâš™ï¸  CONFIGURATION:\033[0m\n'
  printf '\033[0;36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\033[0m\n'
  printf '\033[1mDistribution:\033[0m   \033[0;33m%s %s\033[0m\n' "$DISTRO" "$RELEASE"
  printf '\033[1mContainer Name:\033[0m \033[0;33m%s\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mUsername:\033[0m       \033[0;33m%s\033[0m\n' "$USERNAME"
  printf '\033[1mPassword:\033[0m       \033[0;33m%s\033[0m\n' "$PASSWORD"
  printf '\033[1mResources:\033[0m      \033[0;33m%s vCPUs, %sMB RAM\033[0m\n' "$VCPUS" "$MEMORY_MB"
  printf '\033[1mPrivileged:\033[0m     \033[0;33m%s\033[0m\n' "$PRIVILEGED"
  echo
  # printf "\033[1;36mPress enter to continue...\033[0m\n"
  # read -r
}

configure_distribution() {
  case "$DISTRO" in
  ubuntu)
    RELEASE=${RELEASE:-"questing"}
    IMAGE_URL="images:ubuntu/${RELEASE}/cloud"
    ;;
  fedora)
    RELEASE=${RELEASE:-"43"}
    IMAGE_URL="images:fedora/${RELEASE}/cloud"
    ;;
  arch)
    RELEASE=${RELEASE:-"current"}
    IMAGE_URL="images:archlinux/${RELEASE}/cloud"
    ;;
  debian)
    RELEASE=${RELEASE:-"13"}
    IMAGE_URL="images:debian/${RELEASE}/cloud"
    ;;
  centos)
    RELEASE=${RELEASE:-"9-Stream"}
    IMAGE_URL="images:centos/${RELEASE}/cloud"
    ;;
  tumbleweed | tw)
    RELEASE=${RELEASE:-"current"}
    IMAGE_URL="images:opensuse/tumbleweed/cloud"
    ;;
  alpine)
    RELEASE=${RELEASE:-"3.22"}
    IMAGE_URL="images:alpine/${RELEASE}/cloud"
    ;;
  *)
    fail "Unsupported distribution: $DISTRO"
    fail "Supported distributions: ubuntu, fedora, arch, debian, centos, tumbleweed, alpine"
    exit 1
    ;;
  esac

  CONTAINER_NAME=${CONTAINER_NAME:-"$DISTRO-ict"}
  USERNAME=${USERNAME:=$USER}
  PASSWORD=${PASSWORD:-$(generate_password_for "$CONTAINER_NAME")}
  PASSWORD_HASH=$(openssl passwd -6 "$PASSWORD")

  show_configuration
}

generate_cloud_init_config() {
  slog "Generating cloud-init configuration..."

  CLOUD_INIT_DIR=$(mktemp -d)
  trap '[[ -n "$CLOUD_INIT_DIR" && -d "$CLOUD_INIT_DIR" ]] && rm -rf "$CLOUD_INIT_DIR"' EXIT

  local pub_key
  pub_key=$(cat "$SSH_KEY_PATH")

  local packages_common="curl bash"
  local openssh_pkg

  if [[ "$DISTRO" == "arch" ]]; then
    openssh_pkg="openssh"
  else
    openssh_pkg="openssh-server"
  fi

  local runcmd_lines=(
    "systemctl enable --now ssh || systemctl enable --now sshd || true"
  )

  if [[ "$DISTRO" == "alpine" ]]; then
    runcmd_lines=(
      "rc-update add sshd default"
      "service sshd start"
    )
  fi

  local sudo_groups="wheel"

  if [[ "$DISTRO" == "ubuntu" || "$DISTRO" == "debian" ]]; then
    sudo_groups="sudo"
  fi

  tee "${CLOUD_INIT_DIR}/user-data" >/dev/null <<EOF
#cloud-config
hostname: $CONTAINER_NAME
manage_etc_hosts: true

users:
  - name: $USERNAME
    groups: [ "$sudo_groups" ]
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    lock_passwd: false
    passwd: ${PASSWORD_HASH}
    ssh_authorized_keys:
      - ${pub_key}

package_update: true
package_upgrade: true

packages:
  - $openssh_pkg
$(for pkg in $packages_common; do echo "  - $pkg"; done)

runcmd:
$(for line in "${runcmd_lines[@]}"; do echo "  - $line"; done)

EOF

  tee "${CLOUD_INIT_DIR}/meta-data" >/dev/null <<EOF
instance-id: ${CONTAINER_NAME}-$(date +%s)
local-hostname: $CONTAINER_NAME
EOF

  success "Cloud-init configuration files created in: $CLOUD_INIT_DIR"
}

create_container() {
  incus_instance_exists "$CONTAINER_NAME" && die "instance '$CONTAINER_NAME' already exists"

  slog "Creating Incus LXC container '$CONTAINER_NAME'..."

  generate_cloud_init_config

  slog "Launching container with image: $IMAGE_URL"

  local launch_args=(
    "$IMAGE_URL" "$CONTAINER_NAME"
    --config "limits.cpu=$VCPUS"
    --config "limits.memory=${MEMORY_MB}MB"
    --config "user.user-data=$(cat "${CLOUD_INIT_DIR}/user-data")"
    --config "user.meta-data=$(cat "${CLOUD_INIT_DIR}/meta-data")"
  )

  if [[ "$PRIVILEGED" == "true" ]]; then
    launch_args+=(--config "security.privileged=true")
    slog "Creating privileged container"
  elif [[ "$DISTRO" != "ubuntu" && "$DISTRO" != "debian" ]]; then
    launch_args+=(--config "security.nesting=true")
  fi

  local result=0
  if incus launch "${launch_args[@]}"; then
    success "Container '$CONTAINER_NAME' created successfully"
  else
    fail "Failed to create container '$CONTAINER_NAME'"
    fail "If the error message mentions 'idmap' you should be able to fix it with 'incus-idmap-fix'"
    result=1
  fi

  if [[ -n "$CLOUD_INIT_DIR" && -d "$CLOUD_INIT_DIR" ]]; then
    rm -rf "$CLOUD_INIT_DIR"
    slog "Cleaned up temporary cloud-init files"
  fi

  return $result
}

wait_for_ip() {
  local CONTAINER_NAME="$1"

  printf '\033[1;36mðŸ” Wait for IP address? (Y/n):\033[0m ' >&2
  read -t 5 -r response || response="y"

  case "$response" in
  n | N)
    return 1
    ;;
  *)
    if ! wait_for_vm_state "$CONTAINER_NAME" "RUNNING"; then
      return 1
    fi
    if ! wait_until 30 3 "ict ip $CONTAINER_NAME"; then
      return 1
    fi
    return 0
    ;;
  esac
}

add_ssh_config() {
  has_cmd ssh-config || return 0

  local ip
  ip=$(ict_ip "$CONTAINER_NAME")

  slog "Adding SSH configuration for $CONTAINER_NAME..."
  if ssh-config add --host "$CONTAINER_NAME" --ip "$ip" --user "$USERNAME" --identity "${SSH_KEY_PATH%.pub}"; then
    printf '\033[1mSSH Shortcut:\033[0m  \033[0;33mssh %s\033[0m\n' "$CONTAINER_NAME"
  else
    warn "Failed to add SSH configuration"
  fi
}

show_completion_info() {
  slog "Waiting for container to be ready. This could take a few minutes..."
  if ! wait_for_ip "$CONTAINER_NAME"; then
    fail "Container did not get an IP in time. Try 'ict ip $CONTAINER_NAME' later."
    info "If you still can't connect, Use 'ict console $CONTAINER_NAME' to access it."
    info "If the container has no ip(ip a), try fixing with 'incus-network-fix'"
  fi

  echo
  printf '\033[1;32mâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\033[0m\n'
  printf '\033[1;32mâ”‚\033[1;37m                  CONTAINER CREATED SUCCESSFULLY!          \033[1;32mâ”‚\033[0m\n'
  printf '\033[1;32mâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\033[0m\n'
  echo

  printf '\033[1;36mðŸ“‹ CONTAINER INFORMATION:\033[0m\n'
  printf '\033[0;36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\033[0m\n'
  printf '\033[1mContainer Name:\033[0m \033[0;33m%s\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mDistribution:\033[0m   \033[0;33m%s %s\033[0m\n' "$DISTRO" "$RELEASE"
  printf '\033[1mUsername:\033[0m      \033[0;33m%s\033[0m\n' "$USERNAME"
  printf '\033[1mPassword:\033[0m      \033[0;33m%s\033[0m\n' "$PASSWORD"
  printf '\033[1mResources:\033[0m     \033[0;33m%s vCPUs, %sMB RAM\033[0m\n' "$VCPUS" "$MEMORY_MB"
  printf '\033[1mType:\033[0m          \033[0;33mLXC Container (lightweight, shared kernel)\033[0m\n'
  echo

  printf '\033[1;36mðŸŒ NETWORK ACCESS:\033[0m\n'
  printf '\033[0;36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\033[0m\n'

  local ip
  if ip=$(ict_ip "$CONTAINER_NAME" 2>/dev/null); then
    printf '\033[1mIP Address:\033[0m   \033[0;33m%s\033[0m\n' "$ip"
    printf '\033[1mSSH Command:\033[0m  \033[0;33mssh %s@%s\033[0m\n' "$USERNAME" "$ip"
  else
    printf '\033[1mGet IP Address:\033[0m \033[0;33mict ip %s\033[0m\n' "$CONTAINER_NAME"
  fi
  echo

  printf '\033[1;36mðŸ”§ CONTAINER MANAGEMENT:\033[0m\n'
  printf '\033[0;36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\033[0m\n'
  printf '\033[1mStop:\033[0m     \033[0;33mict stop %s\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mStart:\033[0m    \033[0;33mict start %s\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mDelete:\033[0m   \033[0;33mict delete %s\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mShell:\033[0m    \033[0;33mincus exec %s -- /bin/bash\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mExecute:\033[0m   \033[0;33mincus exec %s -- <command>\033[0m\n' "$CONTAINER_NAME"
  printf '\033[1mStatus:\033[0m    \033[0;33mict status %s\033[0m\n' "$CONTAINER_NAME"
  echo

  success "Container '$CONTAINER_NAME' is ready to use!"
  echo
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    --distro)
      DISTRO="$2"
      shift 2
      ;;
    --name)
      CONTAINER_NAME="$2"
      shift 2
      ;;
    --release)
      RELEASE="$2"
      shift 2
      ;;
    --username)
      USERNAME="$2"
      shift 2
      ;;
    --password)
      PASSWORD="$2"
      shift 2
      ;;
    --vcpus)
      VCPUS="$2"
      shift 2
      ;;
    --memory)
      MEMORY_MB="$2"
      shift 2
      ;;
    --ssh-key)
      SSH_KEY_PATH="$2"
      shift 2
      ;;
    --privileged)
      PRIVILEGED="true"
      shift
      ;;
    --help | -h)
      usage
      exit 0
      ;;
    *)
      fail "Unknown option: $1"
      usage
      exit 1
      ;;
    esac
  done

  if [[ -z "${DISTRO:-}" ]]; then
    fail "Distribution is required. Use --distro option. Use --help for more info."
    exit 1
  fi
}

check_prerequisites() {
  incus_check

  local missing=()

  for cmd in openssl awk grep tee mktemp cat ssh systemctl; do
    if ! has_cmd "$cmd"; then
      missing+=("$cmd")
    fi
  done

  if ((${#missing[@]})); then
    fail "Missing required commands: ${missing[*]}"
    exit 1
  fi

  has_cmd pass || {
    info "pass command not found. Using pass is recommended."
  }
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  check_prerequisites
  slog "Starting Incus LXC container creation..."

  parse_args "$@"
  if [[ -z "${SSH_KEY_PATH:-}" ]]; then
    SSH_KEY_PATH=$(ssh_key_path)
  fi

  file_exists "$SSH_KEY_PATH" || die "SSH public key not found at: $SSH_KEY_PATH"

  configure_distribution
  if create_container; then
    show_completion_info
    add_ssh_config
  fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
