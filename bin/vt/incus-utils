#!/usr/bin/env bash

# shellcheck disable=SC1091

DOT_DIR=${DOT_DIR:-$HOME/.ilm}
source "$DOT_DIR/share/utils"
source "$(dirname "$0")/vt-utils"

export ICT_DISTRO_LIST=("debian" "ubuntu" "fedora" "arch" "tw")

export IVM_DISTRO_LIST=("debian" "ubuntu" "fedora" "arch" "tw")

incus_instance_exists() {
  incus list type=container,virtual-machine --format csv --columns n | grep -q "^$1$"
}

incus_check() {
  if ! has_cmd incus; then
    fail "incus command not found. Please install Incus first."
    exit 1
  fi

  if ! incus info >/dev/null 2>&1; then
    fail "Cannot connect to Incus daemon. Please ensure Incus is running and you have proper permissions."
    exit 1
  fi
}

ivm_check_exists_prerequisites() {
  local missing=()
  for cmd in incus openssl curl wget tee mktemp; do
    if ! has_cmd "$cmd"; then
      missing+=("$cmd")
    fi
  done

  if ((${#missing[@]})); then
    fail "Missing required commands: ${missing[*]}"
    exit 1
  fi

  if ! incus info >/dev/null 2>&1; then
    fail "Cannot connect to Incus daemon. Please ensure Incus is running and you have proper permissions."
    exit 1
  fi

  has_cmd ivm || {
    fail "ivm is not in PATH."
    exit 1
  }

  has_cmd ivm-create || {
    fail "ivm-create is not in PATH."
    exit 1
  }
}

ivm_state() {
  incus info "$1" | grep "Status:" | awk '{print $2}'
}

ivm_exists() {
  incus info "$1" >/dev/null 2>&1
}

ivm_check_exists() {
  if ! ivm_exists "$1"; then
    fail "VM '$1' not found"
    return 1
  fi
}

ivm_running() {
  local vm_name="$1"
  local state
  state=$(ivm_state "$vm_name")
  [[ "$state" == "RUNNING" ]]
}

ivm_check_exists_running() {
  local vm_name="$1"
  ivm_check_exists "$vm_name" || return 1

  local state
  state=$(ivm_state "$vm_name")
  if [[ "$state" != "RUNNING" ]]; then
    fail "VM '$vm_name' is not running (state: ${state:-unknown})"
    return 1
  fi
}

ivm_list() {
  local vm_name="${1:-}"
  local extra_args="${2:---columns=ns4}"

  if [[ -n "$vm_name" ]]; then
    incus list type=virtual-machine "$vm_name" "${extra_args}"
  else
    incus list type=virtual-machine "${extra_args}"
  fi
}

detect_container_user() {
  local container_name="$1"

  # Auto-detect username based on container name patterns
  case "$container_name" in
  ubuntu*) echo "ubuntu" ;;
  fedora*) echo "fedora" ;;
  centos*) echo "centos" ;;
  debian*) echo "debian" ;;
  arch*) echo "arch" ;;
  tumbleweed* | tw*) echo "opensuse" ;;
  *)
    fail "Could not auto-detect username for container '$container_name'. Use 'ict shell $container_name <username>' instead."
    return 1
    ;;
  esac
}

wait_for_vm_state() {
  local vm_name="$1"
  local expected_state="$2"
  local timeout="${3:-60}"
  local interval="${4:-3}"

  local count=0
  local max_attempts=$((timeout / interval))

  while ((count < max_attempts)); do
    local state
    state=$(ivm_state "$vm_name")
    if [[ "$state" == "$expected_state" ]]; then
      return 0
    fi
    sleep "$interval"
    ((count++))
  done
  return 1
}

ivm_ip() {
  local vm_name="$1"

  ivm_check_exists_running "$vm_name" || return 1

  local address_list
  if ! address_list=$(incus list "^${vm_name}$" --format csv --columns 4 2>/dev/null); then
    fail "Unable to fetch network information for VM '$vm_name'"
    return 1
  fi

  address_list=${address_list%\"$'\n'}
  address_list=${address_list#\"}

  local ip
  ip=$(printf '%s\n' "$address_list" | awk '/\((enp|eth)/ {print $1; exit}')

  if [[ -z "$ip" ]]; then
    fail "No suitable IP address found for VM '$vm_name'"
    return 1
  fi

  echo "$ip"
  return 0
}

ivm_show_ip() {
  local vm_name="$1"
  local ip
  if ! ip=$(ivm_ip "$vm_name"); then
    return 1
  fi
  echo "$ip"
}

ivm_ssh() {
  local vm_name="$1"
  local username="${2:-}"

  if [[ -z "$username" ]]; then
    fail "Username required. Usage: $0 ssh <vm_name> <username>"
    return 1
  fi

  local ip
  if ! ip=$(ivm_ip "$vm_name"); then
    return 1
  fi

  local connect_timeout="${IVM_SSH_CONNECT_TIMEOUT:-15}"
  slog "Connecting to $vm_name ($ip) as $username..."
  ssh -o "ConnectTimeout=${connect_timeout}" "$username@$ip"
}

ict_check_prerequisites() {
  local missing=()
  for cmd in incus openssl curl wget tee mktemp; do
    if ! has_cmd "$cmd"; then
      missing+=("$cmd")
    fi
  done

  if ((${#missing[@]})); then
    fail "Missing required commands: ${missing[*]}"
    exit 1
  fi

  if ! incus info >/dev/null 2>&1; then
    fail "Cannot connect to Incus daemon. Please ensure Incus is running and you have proper permissions."
    exit 1
  fi

  has_cmd ict-create || {
    fail "ict-create is not in PATH."
    exit 1
  }

  has_cmd ict || {
    fail "ict is not in PATH."
    exit 1
  }
}

ict_list() {
  incus_check || return 1

  local extra_args="${2:---columns=ns4}"

  slog "Listing all Incus containers..."
  echo

  incus list type=container "${extra_args}"
}

ict_exists() {
  incus list type=container --format csv --columns n | grep -q "^${1}$"
}

ict_check_exists() {
  local container_name="$1"
  if ! ict_exists "$container_name"; then
    fail "Container '$container_name' not found"
    return 1
  fi
}
ict_state() {
  local container_name="$1"
  incus list type=container "$container_name" --format csv --columns s | head -1
}

ict_running() {
  local container_name="$1"
  local state
  state=$(ict_state "$container_name")
  [[ "$state" == "RUNNING" ]]
}

ict_check_running() {
  local container_name="$1"
  if ! ict_running "$container_name"; then
    fail "Container '$container_name' is not running (state: $(ict_state "$container_name"))"
    return 1
  fi
}

ict_check_exists_running() {
  local container_name="$1"
  ict_check_exists "$container_name" || return 1
  ict_check_running "$container_name" || return 1
}

ict_ip() {
  local container_name="$1"

  ict_check_exists_running "$container_name" || return 1

  local address_list
  if ! address_list=$(incus list "^${container_name}$" --format csv --columns 4 2>/dev/null); then
    fail "Unable to fetch network information for container '$container_name'"
    return 1
  fi

  address_list=${address_list%\"$'\n'}
  address_list=${address_list#\"}

  local ip
  ip=$(printf '%s\n' "$address_list" | awk '/\((eth|enp|ens|eno|wlp|lan)/ {print $1; exit}')

  if [[ -z "$ip" ]]; then
    ip=$(printf '%s\n' "$address_list" | awk '{match($0, /([0-9]{1,3}\.){3}[0-9]{1,3}/, m); if (m[0]) {print m[0]; exit}}')
  fi

  if [[ -z "$ip" ]]; then
    fail "No suitable IP address found for container '$container_name'"
    return 1
  fi

  echo "$ip"
  return 0
}

# get_incus_ip() {
#     local name="$1"
#     if [[ -z "$name" ]]; then
#         printf "Usage: get_incus_ip <container>\n" >&2
#         return 1
#     fi

#     # Fetch JSON safely
#     local json
#     if ! json="$(incus list --format json 2>/dev/null)"; then
#         printf "Error: failed to run incus\n" >&2
#         return 1
#     fi

#     # Parse:
#     # - find matching container
#     # - filter only IPv4
#     # - ignore loopback
#     # - return **first** global IPv4
#     local ip
#     ip="$(jq -r --arg n "$name" '
#         .[] | select(.name == $n)
#         | .state.network
#         | to_entries[]
#         | .value.addresses[]
#         | select(.family == "inet")
#         | select(.scope == "global")
#         | .address
#         ' <<< "$json" | head -n1)"

#     if [[ -z "$ip" ]]; then
#         printf "Error: no IPv4 found for container %s\n" "$name" >&2
#         return 1
#     fi

#     printf "%s\n" "$ip"
# }

ict_ssh() {
  local container_name="$1"
  local username="${2:-}"
  ict_check_exists_running "$container_name" || return 1

  # Auto-detect username if not provided
  if [[ -z "$username" ]]; then
    username=$(detect_container_user "$container_name")
    slog "Auto-detected username: $username (override with: $0 ssh $container_name <username>)"
  fi

  local ip
  if ip=$(ict_ip "$container_name"); then
    local connect_timeout="${ICT_SSH_CONNECT_TIMEOUT:-15}"
    slog "Connecting to $container_name ($ip) as $username..."
    if ! ssh -o "ConnectTimeout=${connect_timeout}" "$username@$ip"; then
      local ssh_exit=$?
      fail "SSH connection failed for container '$container_name' (exit code: ${ssh_exit})"
      return "$ssh_exit"
    fi
    return 0
  else
    return $?
  fi

}
