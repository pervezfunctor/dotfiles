#!/usr/bin/env bash

# shellcheck disable=SC1091

set -euo pipefail -o errtrace

source "$(dirname "$0")/dt-utils"
source "$(dirname "$0")/vt-utils"

export DOT_DIR=${DOT_DIR:-$HOME/.ilm}
source "$DOT_DIR/share/dt-fns"

export BOXES_DIR=${USE_BOXES_DIR:-${BOXES_DIR}}

usage() {
  cat <<EOF
Usage: $0 [--root] <command> [container-name] [args...]

Manage distrobox containers similar to VM management.

OPTIONS:
    --root                 Run distrobox commands with distrobox --root

COMMANDS:
    install                 Install container tools (distrobox, podman, etc.) using ilmi
    list                    List all distrobox containers
    status <name>           Show container status and info
    create <distro> [name]  Create a new distrobox container
    create-all [dt-create-multi args]  Create multiple distrobox containers (forwards all args to dt-create-multi)
    start <name>            Start a container
    kill <name>             Force stopa container
    restart <name>          Restart a container
    delete <name>           Delete a container completely
    enter <name>            Enter container shell
    exec <name> <cmd>       Execute command in container
    export <name> <app>     Export application from container
    unexport <app>          Unexport application
    upgrade <name>          Upgrade container packages
    logs <name>             Show container logs
    logs-tail <name>        Follow container logs (like tail -f)

SUPPORTED DISTROS:
    ubuntu, debian, arch, fedora, tumbleweed, alpine, docker, nix

EXAMPLES:
    $0 install                      # Install container tools
    $0 list                         # List all containers
    $0 status ubuntu                # Show status of 'ubuntu' container
    $0 create ubuntu myubuntu       # Create Ubuntu container named 'myubuntu'
    $0 create fedora                # Create Fedora container with default name
    $0 enter ubuntu                 # Enter 'ubuntu' container
    $0 exec ubuntu "ls -la"        # Execute command in 'ubuntu' container
    $0 export ubuntu firefox        # Export firefox from ubuntu container
    $0 logs ubuntu                  # Show logs for 'ubuntu' container
    $0 logs-tail ubuntu             # Follow logs for 'ubuntu' container
    $0 delete old-container         # Delete 'old-container' completely

EOF
}

install_distrobox() {
  slog "Installing distrobox using ilmi..."

  has_cmd ilmi || die "ilmi not found. Quitting"

  if is_atomic; then
    ilmi atomic_distrobox
  else
    ilmi distrobox
  fi

  if has_cmd distrobox; then
    success "Container tools installed successfully!"
  else
    fail "Container tools installation failed. Please check the output above for errors."
    return 1
  fi
}

get_containers_list() {
  dt_distrobox list | awk 'NR>1 {print $3}' | grep -v '^$' || true
}

list_dt() {
  get_containers_list
}

create_dt() {
  local distro="$1"
  local dt_name="${2:-$distro}"

  if dt_exists "$dt_name"; then
    fail "Container '$dt_name' already exists"
    return 1
  fi

  slog "Creating $distro distrobox container: $dt_name"

  if dt-"$distro" "$dt_name"; then
    success "Container '$dt_name' created successfully"
    show_completion_info "$distro" "$dt_name"
  else
    fail "Failed to create container '$dt_name'"
    return 1
  fi
}

start_dt() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  slog "Starting container '$dt_name'..."

  local dt_id
  if has_cmd podman; then
    dt_id=$(podman ps -a --filter "name=${dt_name}" --format "{{.ID}}" | head -1)
    if [[ -n "$dt_id" ]]; then
      podman start "$dt_id" >/dev/null 2>&1 || true
    fi
  elif has_cmd docker; then
    dt_id=$(docker ps -a --filter "name=${dt_name}" --format "{{.ID}}" | head -1)
    if [[ -n "$dt_id" ]]; then
      docker start "$dt_id" >/dev/null 2>&1 || true
    fi
  fi

  success "Container '$dt_name' started (will be fully initialized on first enter)"
}

kill_dt() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  slog "Stopping container '$dt_name'..."

  if dt_distrobox stop --yes "$dt_name"; then
    success "Container '$dt_name' stopped"
  else
    fail "Failed to stop container '$dt_name'"
    return 1
  fi
}

restart_dt() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  slog "Restarting container '$dt_name'..."
  kill_dt "$dt_name"

  while dt_distrobox list | grep -q "\b${dt_name}\b"; do
    sleep 1
  done

  start_dt "$dt_name"
}

delete_dt() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  warn "This will permanently delete container '$dt_name' and all its data!"
  read -p "Are you sure? (y/N): " -r
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    slog "Deletion cancelled"
    return 0
  fi

  slog "Deleting container '$dt_name'..."
  if dt_distrobox rm --force "$dt_name"; then
    success "Container '$dt_name' deleted"

    local home_dir="${BOXES_DIR}/${dt_name}"
    if [[ -d "$home_dir" ]]; then
      slog "Removing container home directory: $home_dir"
      rm -rf "$home_dir"
    fi
  else
    fail "Failed to delete container '$dt_name'"
    return 1
  fi
}

enter_dt() {
  local dt_name="${1:-}"
  if [[ -z "$dt_name" ]]; then
    local containers
    readarray -t containers < <(get_containers_list)
    dt_name=$(select-one "Select container to enter:" "${containers[@]}" || true)
  else
    shift
  fi

  dt_check_exists "$dt_name"

  local args=("$@")
  slog "Entering container '$dt_name'..."
  dt_distrobox enter -nw --clean-path --name "$dt_name" "${args[@]}"
}

exec_dt() {
  local dt_name="${1:-}"

  if [[ -z "$dt_name" ]]; then
    local containers
    readarray -t containers < <(get_containers_list)
    dt_name=$(select-one "Select container to execute command in:" "${containers[@]}" || true)
  else
    shift
  fi

  dt_check_exists "$dt_name"

  slog "Executing command in container '$dt_name': $*"
  dt_distrobox enter -nw --clean-path --name "$dt_name" -- "$@"
}

export_app() {
  local dt_name="$1"
  local app_name="$2"

  dt_check_exists "$dt_name"

  slog "Exporting '$app_name' from container '$dt_name'..."
  if distrobox-export --app "$app_name" --container "$dt_name"; then
    success "Application '$app_name' exported successfully"
  else
    fail "Failed to export application '$app_name'"
    return 1
  fi
}

unexport_app() {
  local app_name="$1"

  slog "Unexporting application '$app_name'..."
  if distrobox-export --app "$app_name" --delete; then
    success "Application '$app_name' unexported successfully"
  else
    fail "Failed to unexport application '$app_name'"
    return 1
  fi
}

upgrade_dt() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  slog "Upgrading packages in container '$dt_name'..."
  if dt_distrobox upgrade "$dt_name"; then
    success "Container '$dt_name' upgraded successfully"
  else
    fail "Failed to upgrade container '$dt_name'"
    return 1
  fi
}

show_logs() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  slog "Showing logs for container '$dt_name'..."
  echo

  local dt_id
  if has_cmd podman; then
    dt_id=$(podman ps -a --filter "name=${dt_name}" --format "{{.ID}}" | head -1)
    if [[ -n "$dt_id" ]]; then
      podman logs "$dt_id" 2>/dev/null || warn "No logs available"
    fi
  elif has_cmd docker; then
    dt_id=$(docker ps -a --filter "name=${dt_name}" --format "{{.ID}}" | head -1)
    if [[ -n "$dt_id" ]]; then
      docker logs "$dt_id" 2>/dev/null || warn "No logs available"
    fi
  else
    warn "No container engine (podman/docker) found"
  fi
}

tail_logs() {
  local dt_name="$1"

  dt_check_exists "$dt_name"

  slog "Following logs for container '$dt_name' (Press Ctrl+C to stop)..."
  echo

  local dt_id
  if has_cmd podman; then
    dt_id=$(podman ps -a --filter "name=${dt_name}" --format "{{.ID}}" | head -1)
    if [[ -n "$dt_id" ]]; then
      podman logs -f "$dt_id" 2>/dev/null || warn "No logs available or container not running"
    else
      warn "Container not found in podman"
    fi
  elif has_cmd docker; then
    dt_id=$(docker ps -a --filter "name=${dt_name}" --format "{{.ID}}" | head -1)
    if [[ -n "$dt_id" ]]; then
      docker logs -f "$dt_id" 2>/dev/null || warn "No logs available or container not running"
    else
      warn "Container not found in docker"
    fi
  else
    warn "No container engine (podman/docker) found"
  fi
}

if [[ $# -eq 0 ]]; then
  usage
  exit 1
fi

if [[ "${1:-}" == "--root" ]]; then
  shift
  dt_enable_root_mode
else
  dt_disable_root_mode
fi

command="${1:-}"
shift

if [[ "$command" != "install" ]]; then
  if ! has_cmd distrobox; then
    fail "distrobox command not found. Please install distrobox first."
    slog "You can install it with: $0 install"
    exit 1
  fi
fi

case "$command" in
install)
  install_distrobox
  ;;
ls | list)
  dt_list
  ;;
# status)
#   dt_state "$dt_name"
#   ;;
create)
  if [[ $# -lt 1 ]]; then
    fail "Usage: $0 create <distro> <container_name>"
    exit 1
  fi
  create_dt "$@"
  ;;
create-all)
  dt-create-multi "$@"
  ;;
start)
  handle_multiple_arguments dt start "$@"
  ;;
kill | force-stop)
  handle_multiple_arguments dt kill "$@"
  ;;
restart)
  handle_multiple_arguments dt restart "$@"
  ;;
rm | delete)
  handle_multiple_arguments dt delete "$@"
  ;;
enter)
  enter_dt "$@"
  ;;
exec)
  exec_dt "$@"
  ;;
export)
  export_app "$@"
  ;;
unexport)
  unexport_app "$@"
  ;;
upgrade)
  handle_multiple_arguments dt upgrade "$@"
  ;;
logs)
  show_logs "$@"
  ;;
logs-tail)
  tail_logs "$@"
  ;;
--help | -h)
  usage
  ;;
*)
  fail "Unknown command: $command"
  usage
  exit 1
  ;;
esac
