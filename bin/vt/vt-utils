#!/usr/bin/env bash

# shellcheck disable=SC1091

export DOT_DIR=${DOT_DIR:-$HOME/.ilm}
source "$DOT_DIR/share/utils"

is_net_service_running() {
  if ! has_cmd ss; then
    fail "ss command not found. Please install it first."
    return 1
  fi

  local service=${1:-ssh}
  sudo ss -tlnp | grep -q "$service"
}

check_tmux() {
  has_cmd tmux && return 0

  fail "tmux is not installed. Please install it first."
  exit 1
}

default_username() {
  local distro="$1"

  local username

  case "$distro" in
  ubuntu*) username="ubuntu" ;;
  fedora*) username="fedora" ;;
  centos*) username="centos" ;;
  debian*) username="debian" ;;
  arch*) username="arch" ;;
  alpine*) username="alpine" ;;
  nix*) username="nixos" ;;
  rocky*) username="rocky" ;;
  tumbleweed* | tw*) username="opensuse" ;;
  *)
    username="$USER"
    ;;
  esac

  echo "$username"
}

add_port_command() {
  local ssh_config="$HOME/.ssh/config"
  touch "$ssh_config"

  if grep -qE "^Host[[:space:]]+\\*-vmu$" "$ssh_config"; then
    return
  fi

  cat <<'EOF' >>"$ssh_config"
Host *-vmu
  HostName 127.0.0.1
  ProxyCommand sh -c 'port=$(grep -m1 "^%h " ~/.vm-ports | awk "{print \$2}"); exec nc 127.0.0.1 $port'
  StrictHostKeyChecking no
  UserKnownHostsFile=/dev/null
  LogLevel ERROR
EOF
}

get_host_nic() {
  ip route show default | awk '/default/ {print $5}'
}

try_value() {
  local cmd out status

  cmd="$1"
  shift
  has_cmd "$cmd" || return 1

  out="$("$cmd" "$@" 2>/dev/null)"
  status=$?

  [ "$status" -eq 0 ] || return 1
  [ -n "$out" ] || return 1

  printf '%s\n' "$out"
  return 0
}

generate_password_for() {
  local vt_name="$1"
  try_value pass generate "$(hostname)/${vt_name}" 12 && return 0
  try_value pwgen 12 1 && return 0
  try_value openssl rand -base64 12 && return 0

  return 1
}

hash_password_for() {
  local password="$1"
  openssl passwd -6 "$password"
}

validate_password() {
  local password="$1"
  if [[ -z "$password" ]]; then
    fail "Password cannot be empty"
    return 1
  fi

  if [[ ${#password} -lt 8 ]]; then
    fail "Password must be at least 8 characters"
    return 1
  fi

  return 0
}

wait_until() {
  local timeout="$1"
  local interval="$2"
  shift 2
  local -a cmd=("$@")
  local count=0
  local max_attempts=$((timeout / interval))

  # Hide cursor
  tput civis 2>/dev/null || true
  echo -n "Waiting" >&2

  while ((count < max_attempts)); do
    if "${cmd[@]}" >/dev/null 2>&1; then
      # Clear the progress line and restore cursor
      echo -ne "\r\033[K" >&2
      tput cnorm 2>/dev/null || true
      return 0
    fi

    # Add a dot for each attempt (cycle through 3 dots)
    local dots=$((count % 3 + 1))
    local dot_display=""
    for ((i = 0; i < dots; i++)); do
      dot_display+="."
    done

    # Update progress display with dots
    echo -ne "\rWaiting${dot_display}" >&2

    sleep "$interval"
    ((count++))
  done

  # Clear the progress line and restore cursor
  echo -ne "\r\033[K" >&2
  tput cnorm 2>/dev/null || true
  return 1
}

stable_hash() {
  local input="$1"
  local digits="${2:-3}"
  local digest mod

  mod=$(printf "%0.s9" $(seq 1 "$digits"))
  mod=$((10#$mod + 1))

  digest=$(printf '%s' "$input" | sha256sum | cut -d' ' -f1)
  printf "%0${digits}d\n" "$((0x${digest:0:8} % mod))"
}

handle_multiple_arguments() {
  if [[ $# -lt 2 ]]; then
    fail "handle_multiple_arguments: requires at least 2 arguments" >&2
    return 1
  fi

  local backend="$1"
  local cmd
  cmd="$2"
  shift 2

  local -a items=("$@")

  #  use fzf if no items were passed
  if [[ ${#items[@]} -eq 0 ]]; then
    local list_fn="list_${backend}"

    if ! fn_exists "$list_fn"; then
      fail "Missing backend function: $list_fn"
      return 1
    fi

    mapfile -t available < <("$list_fn")

    if [[ ${#available[@]} -eq 0 ]]; then
      slog "No items found for '$backend'."
      return 1
    fi

    mapfile -t items < <(select-multi "Select items to ${cmd}:" "${available[@]}")

    [[ ${#items[@]} -gt 0 ]] || {
      slog "Nothing selected."
      return 1
    }
  fi

  # execute handler for each selected item
  local handler="${cmd}_${backend}"
  if ! fn_exists "$handler"; then
    fail "Missing handler: $handler" >&2
    return 1
  fi

  for item in "${items[@]}"; do
    "$handler" "$item"
  done
}

wait_for_ip() {
  local backend="$1"
  local name="$2"

  printf '\033[1;36mWait for IP address? (Y/n):\033[0m ' >&2
  read -t 5 -r response || response="y"

  case "$response" in
  n | N)
    slog "Not waiting for IP."
    return 1
    ;;
  esac

  local state_fn="${backend}_running"
  if ! fn_exists "$state_fn"; then
    fail "Backend missing: $state_fn"
    return 1
  fi

  if wait_until 30 3 "$state_fn" "$name"; then
    slog "Instance is running"
  else
    fail "Instance did not start in time"
    return 1
  fi

  local ip_fn="${backend}_ip"
  if ! fn_exists "$ip_fn"; then
    fail "Backend missing: $ip_fn"
    return 1
  fi

  if wait_until 60 3 "$ip_fn" "$name"; then
    slog "Instance has IP address: $("$ip_fn" "$name")"
    return 0
  else
    fail "Instance did not get IP address in time"
    return 1
  fi
}

select_distributions() {
  local distributions=("$@")
  local prompt="Select distributions to create:"
  local selected_distributions=()

  mapfile -t selected_distributions < <(select-multi "$prompt" "${distributions[@]}")

  printf '%s\n' "${selected_distributions[@]}"
}

create_all_vt() {
  local command="$1"
  local -n distros_ref=$2
  local -n args_ref=$3

  local failed_count=0
  local total_count=${#distros_ref[@]}

  slog "Starting creation of $total_count VMs with $command..."

  for distro in "${distros_ref[@]}"; do
    if ! "$command" --distro "$distro" "${args_ref[@]}"; then
      fail "VM creation for $distro failed"
      ((++failed_count))
    fi

    sleep 2
  done

  if [[ $failed_count -eq 0 ]]; then
    success "All VMs created successfully!"
  else
    info "Total VMs attempted: $total_count"
    info "Successfully created: $((total_count - failed_count))"
    info "Failed: $failed_count"
  fi
}

sshn() {
  local host="$1"
  local port="$2"
  local user="$3"
  local connect_timeout="${4:-15}"

  exec ssh \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -o ConnectTimeout="${connect_timeout}" \
    -o ConnectionAttempts=1 \
    -o LogLevel=ERROR \
    "${user}@${host}" -p "$port"
}
