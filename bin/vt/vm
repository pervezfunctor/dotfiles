#!/bin/bash

set -euo pipefail

DOT_DIR=${DOT_DIR:-$HOME/.ilm}

# shellcheck disable=SC1091
source "$DOT_DIR/share/utils"

usage() {
    cat <<EOF
Usage: $0 <command> [vm-name]

Manage VMs created with libvirt-* scripts.

COMMANDS:
    install             Install virtualization tools using ilmi
    list                List all VMs
    status <vm-name>    Show VM status and info
    create  ARGS        Create a new VM, with same ARGS as vm-create
    autostart <vm-name> Set VM to start on boot
    start <vm-name>     Start a VM
    stop <vm-name>      Gracefully stop a VM
    restart <vm-name>   Restart a VM
    destroy <vm-name>   Force stop a VM
    delete <vm-name>    Delete a VM completely
    console <vm-name>   Connect to VM console
    ip <vm-name>        Get VM IP address
    logs <vm-name>      Show VM logs
    cleanup             Remove stopped VMs and orphaned files
    ssh <vm-name>       Connect to VM via SSH

EXAMPLES:
    $0 install                 # Install virtualization tools
    $0 list                    # List all VMs
    $0 status ubuntu           # Show status of 'ubuntu' VM
    $0 create --distro ubuntu  # Create Ubuntu VM
    $0 start ubuntu            # Start 'ubuntu' VM
    $0 ssh ubuntu              # Connect to 'ubuntu' VM (auto-detects username)
    $0 ssh coreos              # Connect to CoreOS VM as 'core' user
    $0 ssh fedora fedora       # Connect to Fedora VM as 'fedora' user
    $0 delete old-vm           # Delete 'old-vm' completely

EOF
}

list_vms() {
    slog "Listing all VMs..."
    echo
    if has_cmd virsh; then
        virsh list --all
    else
        fail "virsh command not found. Please install virtualization tools first."
        slog "You can install them with: $0 install"
        return 1
    fi
}

install_vm() {
    slog "Installing virtualization tools using ilmi..."

    # Check if ilmi is available
    if has_cmd ilmi; then
        ilmi vm
    else
        fail "ilmi not found."
        return 1
    fi

    if ! has_cmd virsh; then
        fail "Virtualization tools installation failed. Please check the output above for errors."
        return 0
    fi

    success "Virtualization tools installed successfully!"
    echo
    slog "Installed tools include:"
    has_cmd virsh && slog "  ✓ libvirt (virsh)"
    has_cmd qemu-system-x86_64 && slog "  ✓ QEMU"
    has_cmd virt-install && slog "  ✓ virt-install"
    has_cmd vm-create && slog "  ✓ vm-create scripts"
    echo
    slog "You can now use:"
    slog "  $0 list                    # List VMs"
    slog "  $0 create --distro ubuntu  # Create Ubuntu VM"
    slog "  vm-create --distro fedora  # Create Fedora VM with cloud-init"
    echo
    slog "Note: You may need to log out and back in for group changes to take effect."
    slog "Or run: newgrp libvirt"
}

has_vm() {
    virsh dominfo "$1" &>/dev/null
}

check_vm() {
    has_vm "$vm_name" && return 0

    fail "VM '$vm_name' not found"
    return 1
}

vm_status() {
    local vm_name="$1"

    check_vm "$vm_name" || return 1

    slog "Status for VM '$vm_name':"
    echo
    virsh dominfo "$vm_name"
    echo

    slog "Network interfaces:"
    virsh domifaddr "$vm_name" || warn "Could not get IP address (VM may be stopped)"
    echo

    slog "Disk usage:"
    virsh domblklist "$vm_name"
}

create_vm() {
    vm-create "$@"
}

# start vm on boot
autostart_vm() {
    local vm_name="$1"

    check_vm "$vm_name" || return 1

    slog "Setting VM '$vm_name' to start on boot..."
    virsh autostart "$vm_name"
    success "VM '$vm_name' will start on boot"
}

get_vm_state() {
    virsh domstate "$vm_name"
}

start_vm() {
    local vm_name="$1"

    check_vm "$vm_name" || return 1

    local state
    state=$(get_vm_state "$vm_name")

    if [[ "$state" == "running" ]]; then
        warn "VM '$vm_name' is already running"
        return 0
    fi

    slog "Starting VM '$vm_name'..."
    if virsh start "$vm_name"; then
        success "VM '$vm_name' started"
        sleep 2
        slog "Waiting for network..."
        sleep 3
        get_vm_ip "$vm_name"
    else
        fail "Failed to start VM '$vm_name'"
        return 1
    fi
}

stop_vm() {
    local vm_name="$1"

    if ! virsh dominfo "$vm_name" &>/dev/null; then
        fail "VM '$vm_name' not found"
        return 1
    fi

    local state
    state=$(get_vm_state "$vm_name")

    if [[ "$state" != "running" ]]; then
        warn "VM '$vm_name' is not running"
        return 0
    fi

    slog "Gracefully stopping VM '$vm_name'..."
    if virsh shutdown "$vm_name"; then
        success "Shutdown command sent to VM '$vm_name'"
        slog "Waiting for VM to stop..."

        # Wait up to 60 seconds for graceful shutdown
        local count=0
        while [[ $count -lt 20 ]]; do
            state=$(virsh domstate "$vm_name")
            if [[ "$state" == "shut off" ]]; then
                success "VM '$vm_name' stopped gracefully"
                return 0
            fi
            sleep 3
            ((count++))
        done

        warn "VM didn't stop gracefully, forcing shutdown..."
        virsh destroy "$vm_name"
        success "VM '$vm_name' force stopped"
    else
        fail "Failed to stop VM '$vm_name'"
        return 1
    fi
}

restart_vm() {
    local vm_name="$1"

    slog "Restarting VM '$vm_name'..."
    stop_vm "$vm_name"
    sleep 2
    start_vm "$vm_name"
}

destroy_vm() {
    local vm_name="$1"
    check_vm "$vm_name" || return 1

    warn "Force stopping VM '$vm_name'..."
    if virsh destroy "$vm_name"; then
        success "VM '$vm_name' force stopped"
    else
        warn "VM '$vm_name' was not running or already stopped"
    fi
}

delete_vm() {
    local vm_name="$1"
    check_vm "$vm_name" || return 1

    warn "This will permanently delete VM '$vm_name' and all its data!"
    read -p "Are you sure? (y/N): " -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        slog "Deletion cancelled"
        return 0
    fi

    local state
    state=$(get_vm_state "$vm_name")
    if [[ "$state" == "running" ]]; then
        slog "Stopping VM first..."
        virsh destroy "$vm_name"
    fi

    local disks
    disks=$(virsh domblklist "$vm_name" --details | awk '/file.*disk/ {print $4}')

    slog "Removing VM definition..."
    if virsh undefine "$vm_name"; then
        success "VM '$vm_name' undefined"
    fi

    if [[ -n "$disks" ]]; then
        slog "Removing disk files..."
        while IFS= read -r disk; do
            if [[ -f "$disk" ]]; then
                slog "Removing disk: $disk"
                sudo rm -f "$disk"
            fi
        done <<<"$disks"
    fi

    local workdir="/var/lib/libvirt/images/${vm_name}-vm"
    if [[ -d "$workdir" ]]; then
        slog "Removing working directory: $workdir"
        sudo rm -rf "$workdir"
    fi

    success "VM '$vm_name' completely deleted"
}

connect_console() {
    local vm_name="$1"
    check_vm "$vm_name" || return 1

    local state
    state=$(virsh domstate "$vm_name")

    if [[ "$state" != "running" ]]; then
        fail "VM '$vm_name' is not running"
        slog "Start it with: $0 start $vm_name"
        return 1
    fi

    slog "Connecting to console of VM '$vm_name'..."
    slog "Press Ctrl+] to exit console"
    echo
    virsh console "$vm_name"
}

get_vm_ip() {
    local vm_name="$1"
    check_vm "$vm_name" || return 1

    local state
    state=$(virsh domstate "$vm_name")

    if [[ "$state" != "running" ]]; then
        return 2
    fi

    local ip
    ip=$(virsh domifaddr "$vm_name" --source agent | awk '/enp/ {sub(/\/.*/, "", $4); print $4}')

    if [[ -z "$ip" ]]; then
        ip=$(virsh net-dhcp-leases default 2>/dev/null | grep "$vm_name" | awk '{print $5}' | cut -d'/' -f1 | head -1)
    fi

    if [[ -z "$ip" ]]; then
        return 3
    fi

    echo "$ip"
    return 0
}

show_logs() {
    local vm_name="$1"
    check_vm "$vm_name" || return 1

    slog "Showing logs for VM '$vm_name'..."
    echo

    local log_file="/var/log/libvirt/qemu/${vm_name}.log"
    if [[ -f "$log_file" ]]; then
        slog "Libvirt logs:"
        sudo tail -20 "$log_file"
    else
        warn "No libvirt log file found at $log_file"
    fi
}

cleanup_vms() {
    slog "Cleaning up stopped VMs and orphaned files..."

    # List stopped VMs
    local stopped_vms
    stopped_vms=$(virsh list --inactive --name)

    if [[ -n "$stopped_vms" ]]; then
        slog "Stopped VMs found:"
        echo "$stopped_vms"
        echo

        read -p "Remove all stopped VMs? (y/N): " -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            while IFS= read -r vm; do
                if [[ -n "$vm" ]]; then
                    slog "Removing stopped VM: $vm"
                    delete_vm "$vm" </dev/null
                fi
            done <<<"$stopped_vms"
        fi
    else
        slog "No stopped VMs found"
    fi

    slog "Checking for orphaned working directories..."
    for dir in /var/lib/libvirt/images/*-vm; do
        if [[ -d "$dir" ]]; then
            local vm_name
            vm_name=$(basename "$dir" | sed 's/-vm$//')
            if ! virsh dominfo "$vm_name" &>/dev/null; then
                warn "Found orphaned directory: $dir"
                read -p "Remove orphaned directory $dir? (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    sudo rm -rf "$dir"
                    success "Removed: $dir"
                fi
            fi
        fi
    done

    success "Cleanup complete"
}

ip_errors() {
    local ret=$1
    local vm_name=$2

    if [[ $ret -eq 1 ]]; then
        fail "VM '$vm_name' not found"
        return 1
    elif [[ $ret -eq 2 ]]; then
        fail "VM '$vm_name' is not running"
        return 1
    elif [[ $ret -eq 3 ]]; then
        fail "Could not determine IP address for VM '$vm_name'"
        return 1
    fi

}

ssh_to_vm() {
    local vm_name="$1"
    local username="${2:-}"
    check_vm "$vm_name" || return 1

    local state
    state=$(virsh domstate "$vm_name")

    if [[ "$state" != "running" ]]; then
        fail "VM '$vm_name' is not running"
        slog "Start it with: $0 start $vm_name"
        return 1
    fi

    if [[ -z "$username" ]]; then
        username="$vm_name"
        slog "Auto-detected username: $username (override with: $0 ssh $vm_name <username>)"
    fi

    local ip
    ip=$(get_vm_ip "$vm_name")
    local ret=$?
    ip_errors "$ret" "$vm_name"

    slog "Connecting to $vm_name ($ip) as $username..."
    ssh "$username@$ip"
}

show_ip() {
    local ip
    ip=$(get_vm_ip "$vm_name")
    local ret=$?
    ip_errors "$ret" "$vm_name"

    if [[ -n "$ip" ]]; then
        echo "$ip"
    else
        fail "Could not determine IP address for VM '$vm_name'"
        return 1
    fi
}

if [[ $# -eq 0 ]]; then
    usage
    exit 1
fi

command="$1"
vm_name="${2:-}"

case "$command" in
install)
    install_vm
    ;;
list)
    list_vms
    ;;
status)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    vm_status "$vm_name"
    ;;
create)
    vm-create "${@:2}"
    ;;
autostart)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    autostart_vm "$vm_name"
    ;;
start)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    start_vm "$vm_name"
    ;;
stop)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    stop_vm "$vm_name"
    ;;
restart)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    restart_vm "$vm_name"
    ;;
destroy)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    destroy_vm "$vm_name"
    ;;
delete)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    delete_vm "$vm_name"
    ;;
console)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    connect_console "$vm_name"
    ;;
ip)
    show_ip "$vm_name"
    ;;
logs)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    show_logs "$vm_name"
    ;;
cleanup)
    cleanup_vms
    ;;
ssh)
    [[ -z "$vm_name" ]] && {
        fail "VM name required"
        usage
        exit 1
    }
    ssh_to_vm "$vm_name" "${3:-}"
    ;;
--help | -h)
    usage
    ;;
*)
    fail "Unknown command: $command"
    usage
    exit 1
    ;;
esac
