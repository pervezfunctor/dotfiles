#!/usr/bin/env bash

# shellcheck disable=SC2120

export BOXES_DIR=${USE_BOXES_DIR:-${BOXES_DIR}}

has_cmd distrobox || return 0

dbox-logs() {
  podman logs "$1"
}

dbox_enter() {
  local CONTAINER_NAME=${1}
  shift
  distrobox enter -nw --clean-path --name "${CONTAINER_NAME}" -- "$@"
}

dbox_enter_root() {
  local CONTAINER_NAME=${1}
  shift
  distrobox enter -nw --clean-path --root --name "${CONTAINER_NAME}" -- "$@"
}

dbox_exec() {
  local CONTAINER_NAME=${1}
  shift

  dbox_enter "${CONTAINER_NAME}" -- "$@"
}

dbox_exec_root() {
  local CONTAINER_NAME=${1}
  shift

  dbox_enter_root "${CONTAINER_NAME}" -- "$@"
}

dbox_bash_exec() {
  local CONTAINER_NAME=${1}
  shift

  dbox_enter "${CONTAINER_NAME}" -- bash -c "$*"
}

dbox_create() {
  local CONTAINER_NAME=${1}
  local IMAGE=${2}
  shift 2

  if distrobox list | grep -q "^${CONTAINER_NAME}$"; then
    slog "Distrobox ${CONTAINER_NAME} already exists, skipping creation"
    return 0
  fi

  if dir_exists "${BOXES_DIR}/${CONTAINER_NAME}"; then
    fail "Directory ${BOXES_DIR}/${CONTAINER_NAME} already exists, refusing to create distrobox"
    return 1
  fi

  slog "Creating Ubuntu distrobox: ${CONTAINER_NAME}"
  if distrobox create \
    --hostname "${CONTAINER_NAME}" \
    --yes \
    --image "$IMAGE" \
    --home "${BOXES_DIR}/${CONTAINER_NAME}" \
    --name "$CONTAINER_NAME" \
    "$@"; then
    slog "Distrobox ${CONTAINER_NAME} created successfully"
    slog "Use dbe ${CONTAINER_NAME} to enter"
    return 0
  else
    fail "Failed to create distrobox ${CONTAINER_NAME}"
    return 1
  fi
}

dbox_create_root() {
  local CONTAINER_NAME=${1}
  local IMAGE=${2}
  shift 2

  if dbox_create "$CONTAINER_NAME" "$IMAGE" --root "$@"; then
    slog "Distrobox ${CONTAINER_NAME} created successfully"
    slog "Use rdbe ${CONTAINER_NAME} to enter"
    return 0
  else
    fail "Failed to create distrobox ${CONTAINER_NAME}"
    return 1
  fi
}

dbox-ubuntu-noinit() {
  local CONTAINER_NAME=${1:-ubuntu-noinit}
  dbox_create "${CONTAINER_NAME}" ubuntu:questing
}

dbox-arch-noinit() {
  local CONTAINER_NAME=${1:-arch-noinit}
  dbox_create "${CONTAINER_NAME}" archlinux:latest
}

dbox-fedora-minimal-noinit() {
  local CONTAINER_NAME=${1:-fedora-minimal-noinit}
  dbox_create "${CONTAINER_NAME}" registry.fedoraproject.org/fedora-minimal:latest
}

dbox-debian-slim-noinit() {
  local CONTAINER_NAME=${1:-debian-slim-noinit}
  dbox_create "${CONTAINER_NAME}" debian:trixie-slim
}

dbox-fedora-noinit() {
  local CONTAINER_NAME=${1:-fedora-noinit}
  dbox_create "${CONTAINER_NAME}" fedora:latest
}

dbox-centos-noinit() {
  local CONTAINER_NAME=${1:-centos-noinit}
  dbox_create "${CONTAINER_NAME}" centos:latest
}

dbox-debian-noinit() {
  local CONTAINER_NAME=${1:-debian-noinit}
  dbox_create "${CONTAINER_NAME}" debian:latest
}

dbox-rocky-noinit() {
  local CONTAINER_NAME=${1:-rocky-noinit}
  dbox_create "${CONTAINER_NAME}" rockylinux:9
}

dbox-tw-noinit() {
  local CONTAINER_NAME=${1:-tw-noinit}
  dbox_create "${CONTAINER_NAME}" opensuse/tumbleweed
}

dbox-bluefin() {
  local CONTAINER_NAME=${1:-bluefin-cli}
  dbox_create "${CONTAINER_NAME}" ghcr.io/ublue-os/bluefin-cli
}

dbox-wolfi() {
  local CONTAINER_NAME=${1:-wolfi-ublue}
  dbox_create "${CONTAINER_NAME}" ghcr.io/ublue-os/wolfi-toolbox
}

dbox-virt-manager() {
  local CONTAINER_NAME=${1:-virt-manager}

  local PKGS=(
    openssh-server
    patterns-server-kvm_server
    patterns-server-kvm_tools
    qemu-extra
    qemu-linux-user
    qemu-hw-display-virtio-gpu
    qemu-ui-opengl
    qemu-spice
    spice-gtk
    libvirglrenderer1
    xmlstarlet
    jq
  )

  local services=(
    sshd.service
    virtqemud.socket
    virtnetworkd.socket
    virtstoraged.socket
    virtnodedevd.socket
  )

  dbox_create_root "${CONTAINER_NAME}" registry.opensuse.org/opensuse/distrobox:latest \
    --pull \
    --init \
    --unshare-all \
    --additional-flags "-p 2222:22" \
    --init-hooks "zypper in -y --no-recommends ${PKGS[*]} && systemctl enable ${services[*]} && usermod -aG libvirt $USER"
}

dbox-fedora-virt-manager() {
  local CONTAINER_NAME=${1:-fedora-virt-manager}
  local PKGS=(
    openssh-server
    libvirt
    virt-install
    virt-manager
  )
  local services=(
    sshd.service
    virtqemud.socket
    virtnetworkd.socket
    virtstoraged.socket
    virtnodedevd.socket
  )
  dbox_create_root "${CONTAINER_NAME}" registry.fedoraproject.org/fedora:latest \
    --pull --init --unshare-all \
    --additional-flags "-p 2222:22" \
    --init-hooks "dnf install -y --skip-unavailable ${PKGS[*]} && systemctl enable ${services[*]} && usermod -aG libvirt $USER"
}

dbox-docker-base() {
  local CONTAINER_NAME=${1:-docker-base}

  dbox_create_root "${CONTAINER_NAME}" fedora:latest \
    --additional-packages "systemd docker" \
    --init \
    --unshare-all

  dbox_exec "${CONTAINER_NAME}" --root sudo systemctl enable --now docker
  dbox_exec "${CONTAINER_NAME}" --root sudo usermod -aG docker "$USER"
}

dbox-docker-slim() {
  local CONTAINER_NAME=${1:-docker}
  slog "Creating Docker distrobox: ${CONTAINER_NAME}"
  sudo mkdir -p /var/lib/docker

  dbox_create_root "${CONTAINER_NAME}" ghcr.io/ublue-os/docker-distrobox:latest \
    --init --unshare-all --no-entry \
    --volume /var/lib/docker \
    --additional-packages "systemd libpam-systemd"
}

dbox-docker() {
  local CONTAINER_NAME=${1:-docker}
  dbox-docker-slim "${CONTAINER_NAME}"

  if distrobox enter -nw --clean-path --root --name "${CONTAINER_NAME}" -- bash -c "$(curl -sSL "${ILM_SETUP_URL}")" -- dbox-docker-dev; then
    ssh-copy-id "${USER}@$(dbox-root-ssh docker)"
  fi
}

dbox-incus() {
  local CONTAINER_NAME=${1:-incus}
  slog "Creating Incus distrobox: ${CONTAINER_NAME}"
  sudo mkdir -p /var/lib/incus

  dbox_create_root "${CONTAINER_NAME}" ghcr.io/ublue-os/incus-distrobox:latest \
    --init --unshare-all --no-entry \
    --volume /var/lib/incus:/var/lib/incus \
    --volume /lib/modules:/lib/modules:ro \
    --additional-packages "systemd libpam-systemd" \
    --init-hooks "usermod -aG incus-admin ${USER}"
}

dbox-alpine-edge() {
  local CONTAINER_NAME=${1:-alpine-edge}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" quay.io/toolbx-images/alpine-toolbox:edge \
    --init \
    --additional-packages "openrc openssh-server"

  dbox_exec "${CONTAINER_NAME}" rc-update add sshd default
}

dbox-alpine() {
  local CONTAINER_NAME=${1:-alpine}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" quay.io/toolbx-images/alpine-toolbox:latest \
    --init --additional-packages "openrc openssh-server"

  dbox_exec "${CONTAINER_NAME}" rc-update add sshd default
}

dbox-debian() {
  local CONTAINER_NAME=${1:-debian}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" debian:latest \
    --init \
    --additional-packages "systemd libpam-systemd openssh-server"

  dbox_exec "${CONTAINER_NAME}" systemctl enable sshd
}

dbox-ubuntu() {
  local CONTAINER_NAME=${1:-ubuntu}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" ubuntu:questing \
    --init \
    --additional-packages "systemd libpam-systemd openssh-server"

  dbox_exec "${CONTAINER_NAME}" systemctl enable sshd
}

dbox-arch() {
  local CONTAINER_NAME=${1:-arch}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" archlinux:latest \
    --yes \
    --init \
    --additional-packages "systemd openssh-server"

  dbox_exec "${CONTAINER_NAME}" systemctl enable sshd
}

dbox-tw() {
  local CONTAINER_NAME=${1:-tw}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" opensuse/tumbleweed \
    --init \
    --additional-packages "systemd openssh-server"

  dbox_exec "${CONTAINER_NAME}" systemctl enable sshd
}

dbox-fedora() {
  local CONTAINER_NAME=${1:-fedora}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" fedora:latest \
    --init \
    --additional-packages "systemd openssh-server"

  dbox_exec "${CONTAINER_NAME}" systemctl enable sshd
}

dbox-alpine-noinit() {
  local CONTAINER_NAME=${1:-alpine-noinit}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" quay.io/toolbx-images/alpine-toolbox:latest \
    --additional-packages "gcc libc-dev make gzip zsh git curl neovim tmux ripgrep luarocks fzf eza zoxide github-cli delta bat trash-cli"
}

dbox-alpine-edge-noinit() {
  local CONTAINER_NAME=${1:-alpine-edge-noinit}
  slog "Creating distrobox $CONTAINER_NAME"

  dbox_create "${CONTAINER_NAME}" \
    quay.io/toolbx-images/alpine-toolbox:edge \
    --additional-packages "gcc libc-dev make gzip zsh git curl neovim tmux ripgrep luarocks fzf eza zoxide github-cli delta bat trash-cli"
}

dbox-dev-default() {
  distrobox create --yes
  distrobox enter -nw --clean-path -- bash -c "$(curl -sSL "${ILM_SETUP_URL}")" -- dbox-dev-atomic
  slog "Default distrobox created!"
}

# shellcheck disable=SC2120
dbox-dev() {
  slog "Creating default distrobox"

  local os
  os=${1:-fedora}
  local CONTAINER_NAME=${2:-dev}

  if [[ ! "$os" =~ ^(ubuntu|debian|arch|tw|fedora)$ ]]; then
    fail "Invalid OS type: $os"
    slog "Valid options are: ubuntu, debian, arch, tw, fedora"
    return 1
  fi

  "dbox-$os" "$CONTAINER_NAME"

  if distrobox enter -nw --clean-path --name "${CONTAINER_NAME}" -- bash -c "$(curl -sSL "${ILM_SETUP_URL}")" -- dbox-dev-atomic; then
    slog "Distrobox ${CONTAINER_NAME} setup successfully"
    slog "Use dbe ${CONTAINER_NAME} to enter"
    return 0
  else
    fail "Failed to setup distrobox ${CONTAINER_NAME}"
    return 1
  fi
}

dbox-main-install() {
  if [[ $# -lt 2 ]]; then
    fail "Usage: dbox-main-install <distro> <mainstall> [name]"
    return 1
  fi
  local distro=$1
  local mainstall=$2
  local name=${3:-"${distro}-${mainstall}-test"}

  "dbox-$distro" "$name"
  distrobox enter -nw --clean-path --name "$name" -- bash -c "$(curl -sSL "${ILM_SETUP_URL}")" -- "$mainstall"
}

dbox-group-install() {
  if [[ $# -lt 2 ]]; then
    fail "Usage: dbox-group-install <distro> <groupstall> [name]"
    return 1
  fi
  local distro=$1
  local groupstall=$2
  local name=${3:-"${distro}-${groupstall}-test"}

  "dbox-$distro" "$name"
  distrobox enter -nw --clean-path --name "$name" -- bash -c "$(curl -sSL "${ILM_SETUP_URL}")"
  distrobox enter -nw --clean-path --name "$name" -- ilmg "@$groupstall"
}

dbox-ublue-all() {
  slog "Creating Bluefin, Wolfi and Ublue distroboxes"
  dbox-bluefin
  dbox-wolfi
  dbox-docker
  dbox-incus

  distrobox create \
    --hostname ubuntu-ublue \
    --yes \
    --image ghcr.io/ublue-os/ubuntu-toolbox:latest \
    --init \
    --additional-packages "systemd libpam-systemd" \
    --home "${BOXES_DIR}"/ubuntu-ublue \
    --name ubuntu-ublue

  distrobox create \
    --hostname fedora-ublue \
    --yes \
    --image ghcr.io/ublue-os/fedora-toolbox:latest \
    --init \
    --additional-packages "systemd" \
    --home "${BOXES_DIR}"/fedora-ublue \
    --name fedora-ublue

  distrobox create \
    --hostname arch-ublue \
    --yes \
    --image ghcr.io/ublue-os/arch-distrobox:latest \
    --init \
    --additional-packages "systemd" \
    --home "${BOXES_DIR}"/arch-ublue \
    --name arch-ublue

  slog "Creating Bluefin, Wolfi and Ublue distroboxes done!"
}

dbox-alpine-toolbox() {
  dbox_create alpine-toolbox quay.io/toolbx-images/alpine-toolbox:latest
}

dbox-arch-toolbox() {
  dbox_create arch-toolbox quay.io/toolbx/arch-toolbox:latest \
    --init \
    --additional-packages "systemd"
}

dbox-fedora-toolbox() {
  dbox_create fedora-toolbox quay.io/fedora/fedora-toolbox:42 \
    --init \
    --additional-packages "systemd"
}

dbox-centos-toolbox() {
  dbox_create centos-toolbox quay.io/toolbx-images/centos-toolbox:latest \
    --init \
    --additional-packages "systemd"
}

dbox-debian-toolbox() {
  dbox_create debian-toolbox quay.io/toolbx-images/debian-toolbox:latest \
    --init \
    --additional-packages "systemd"
}

dbox-rockylinux-toolbox() {
  dbox_create rockylinux-toolbox quay.io/toolbx-images/rockylinux-toolbox:latest \
    --init \
    --additional-packages "systemd"
}

dbox-ubuntu-toolbox() {
  dbox_create ubuntu-toolbox quay.io/toolbx/ubuntu-toolbox:latest \
    --init \
    --additional-packages "systemd libpam-systemd"
}

dbox-toolbox-all() {
  dbox-alpine-toolbox
  dbox-arch-toolbox
  dbox-fedora-toolbox
  dbox-centos-toolbox
  dbox-debian-toolbox
  dbox-rockylinux-toolbox
  dbox-ubuntu-toolbox
}

dbox-nvidia-container-toolkit() {
  if has_cmd podman; then
    dbox_create example-nvidia-toolkit docker.io/nvidia/cuda \
      --additional-flags "--gpus all"
  elif has_cmd docker; then
    dbox_create example-nvidia-toolkit docker.io/nvidia/cuda \
      --additional-flags "--gpus all --device=nvidia.com/gpu=all"
  else
    warn "podman or docker not found"
  fi
}

dbox-to-image() {
  if has_cmd podman; then
    podman container commit -p dbox_name "$1"
    podman save "$1":latest | bzip2 >"$1".tar.bz
  elif has_cmd docker; then
    docker container commit -p dbox_name "$1"
    docker save "${1}:latest" | gzip >"$1".tar.gz
  fi
}

dbox-from-image() {
  local dbox_name=${1:dbox}
  slog "Creating distrobox from image $1"

  if distrobox create \
    --hostname "${dbox_name}" \
    --yes \
    --image "$1":latest \
    --name "$dbox_name"; then
    distrobox enter -nw --clean-path --name "$dbox_name"
    slog "Done creating distrobox from image $1"
  fi
}

dbox-nix() {
  local CONTAINER_NAME=${1:-deb-nix}

  slog "Creating distrobox $CONTAINER_NAME"

  srm "${BOXES_DIR}/${CONTAINER_NAME}"

  if dbox-debian "$CONTAINER_NAME"; then
    distrobox enter -nw --clean-path --name "${CONTAINER_NAME}" -- bash -c "$(curl -sSL "${ILM_SETUP_URL}")" -- nix
    slog "Done creating distrobox $CONTAINER_NAME"
  fi
}

dbox-containers() {
  podman ps -a -s
}

dbox-static-network-create() {
  local network=${1:-default}
  local subnet=${2:-"192.168.100.0/24"}

  podman network create --subnet="${subnet}" "${network}"
}

dbox-static-network-remove() {
  local network=${1:-default}

  podman network rm "${network}"
}

dbox-static-ip() {
  local CONTAINER_NAME=${1:-static-box}
  local IP_ADDR=${2:-"192.168.100.10"}

  slog "Creating distrobox ${CONTAINER_NAME} with static IP ${IP_ADDR}"
  distrobox create \
    --yes \
    --image ubuntu:22.04 \
    --name "${CONTAINER_NAME}" \
    --unshare-netns \
    --additional-flags "--network default --ip ${IP_ADDR}"
}

dbox_root_list() {
  distrobox list --root --no-color | tail -n +2 | awk '{print $3}'
}

dbox_root_exists() {
  distrobox list --root | grep -Fq -- "${CONTAINER_NAME}"
}

dbox-root-ip() {
  local CONTAINER_NAME=${1}
  local CONTAINER_ENGINE
  local IP_ADDRESS

  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo "Usage: dbox-root-ip <container-name>" >&2
    echo "Shows the IP address of a distrobox container" >&2
    return 1
  fi

  if ! dbox_root_exists "${CONTAINER_NAME}"; then
    echo "Error: Container '${CONTAINER_NAME}' not found" >&2
    return 1
  fi

  if has_cmd podman && sudo podman ps -a --format "{{.Names}}" | grep -Fqx -- "${CONTAINER_NAME}"; then
    CONTAINER_ENGINE="podman"
  elif has_cmd docker && docker ps -a --format "{{.Names}}" | grep -Fqx -- "${CONTAINER_NAME}"; then
    CONTAINER_ENGINE="docker"
  else
    echo "Error: Could not find container '${CONTAINER_NAME}' with podman or docker" >&2
    return 1
  fi

  case "${CONTAINER_ENGINE}" in
  podman)
    if ! IP_ADDRESS=$(sudo podman inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${CONTAINER_NAME}"); then
      echo "Error: Failed to inspect podman container '${CONTAINER_NAME}'" >&2
      return 1
    fi
    ;;
  docker)
    if ! IP_ADDRESS=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${CONTAINER_NAME}"); then
      echo "Error: Failed to inspect docker container '${CONTAINER_NAME}'" >&2
      return 1
    fi
    ;;
  esac

  if [[ -z "${IP_ADDRESS}" ]]; then
    echo "Error: Container '${CONTAINER_NAME}' does not have an assigned IP address" >&2
    return 1
  fi

  printf '%s\n' "${IP_ADDRESS}"
}

dbox-root-ssh() {
  local CONTAINER_NAME=${1}
  local USER=${2:-$USER}
  local PORT=${3:-22}
  local CONTAINER_IP

  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo "Usage: dbox-root-ssh <container-name> [user] [port]" >&2
    return 1
  fi

  if ! CONTAINER_IP=$(dbox-root-ip "${CONTAINER_NAME}"); then
    echo "Error: Could not determine IP address for container '${CONTAINER_NAME}'" >&2
    return 1
  fi

  echo "Connecting to ${CONTAINER_NAME} at ${CONTAINER_IP}:${PORT} as ${USER}..."
  ssh -p "${PORT}" "${USER}@${CONTAINER_IP}"
}

check_whiptail() {
  has_cmd whiptail && return 0

  echo "Error: whiptail is not installed. Please install it to use dbox-root-ssh-tui."
  echo "On Ubuntu/Debian: sudo apt install whiptail"
  echo "On Fedora: sudo dnf install newt"
  echo "On Arch: sudo pacman -S newt"
}

dbox-root-ssh-tui() {
  local CONTAINER_LIST
  local CONTAINER_NAME
  local CONTAINER_IP
  local USER=${1:-$USER}
  local PORT=${2:-22}
  local MENU_ITEMS=()
  local i=0

  check_whiptail || return 1

  CONTAINER_LIST=$(dbox_root_list)

  if [[ -z "${CONTAINER_LIST}" ]]; then
    whiptail --title "Distrobox SSH" --msgbox "No distrobox containers found." 10 40
    return 0
  fi

  while IFS= read -r CONTAINER_NAME; do
    if [[ -n "${CONTAINER_NAME}" ]]; then
      if CONTAINER_IP=$(dbox-root-ip "${CONTAINER_NAME}" 2>/dev/null); then
        MENU_ITEMS+=("${CONTAINER_NAME}" "${CONTAINER_IP}")
      else
        MENU_ITEMS+=("${CONTAINER_NAME}" "IP not available")
      fi
      ((i++))
    fi
  done <<<"${CONTAINER_LIST}"

  CONTAINER_NAME=$(whiptail --title "Distrobox SSH" \
    --menu "Select a container to SSH into (as ${USER} on port ${PORT}):" \
    20 60 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3)

  if [[ $? -ne 0 || -z "${CONTAINER_NAME}" ]]; then
    echo "Cancelled."
    return 0
  fi

  if ! CONTAINER_IP=$(dbox-root-ip "${CONTAINER_NAME}"); then
    whiptail --title "Error" --msgbox "Could not determine IP address for container '${CONTAINER_NAME}'" 10 40
    return 1
  fi

  echo "Connecting to ${CONTAINER_NAME} at ${CONTAINER_IP}:${PORT} as ${USER}..."
  ssh -p "${PORT}" "${USER}@${CONTAINER_IP}"
}

dbox_root_list-ips() {
  local CONTAINER_LIST
  local CONTAINER_NAME
  local CONTAINER_IP

  CONTAINER_LIST=$(dbox_root_list)

  if [[ -z "${CONTAINER_LIST}" ]]; then
    echo "No distrobox containers found."
    return 0
  fi

  echo "Distrobox Containers and IP Addresses:"
  echo "====================================="
  printf "%-20s %-15s\n" "Container Name" "IP Address"
  echo "-------------------------------------"

  while IFS= read -r CONTAINER_NAME; do
    if [[ -n "${CONTAINER_NAME}" ]]; then
      if CONTAINER_IP=$(dbox-root-ip "${CONTAINER_NAME}" 2>/dev/null); then
        printf "%-20s %-15s\n" "${CONTAINER_NAME}" "${CONTAINER_IP}"
      else
        printf "%-20s %-15s\n" "${CONTAINER_NAME}" "N/A"
      fi
    fi
  done <<<"${CONTAINER_LIST}"
}

vscode-dbox-root-ssh() {
  local CONTAINER_NAME=${1:-docker}
  local USER=${2:-$USER}
  local PORT=${3:-22}

  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo "Usage: vscode-dbox-root-ssh <container-name> [user] [port] [open-code] [pubkey] [known-dir] [strict-host-key-checking]" >&2
    echo "Connect VS Code to a root distrobox container via SSH" >&2
    return 1
  fi

  local CONTAINER_IP
  if ! CONTAINER_IP=$(dbox-root-ip "${CONTAINER_NAME}"); then
    echo "Error: Could not determine IP address for container '${CONTAINER_NAME}'" >&2
    return 1
  fi

  if ! has_cmd code; then
    echo "VS Code not found."
  fi

  echo "Connecting to ${CONTAINER_NAME} at ${CONTAINER_IP}:${PORT} as ${USER}..."
  code --remote "ssh-remote+${USER}@${CONTAINER_IP}" # -- "~-container-${CONTAINER_NAME}"
}
