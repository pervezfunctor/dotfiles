#!/usr/bin/env bash

export BOXES_DIR=${USE_BOXES_DIR:-${BOXES_DIR}}

if is_linux; then
  alias open="xdg-open"

  pbcopy() {
    if [ "$XDG_SESSION_TYPE" = "wayland" ]; then
      wl-copy
    else
      xsel --clipboard --input
    fi
  }

  pbpaste() {
    if [ "$XDG_SESSION_TYPE" = "wayland" ]; then
      wl-paste --no-newline
    else
      xsel --clipboard --output
    fi
  }
fi

alias m="mkdir -p"

if has_cmd code; then
  alias c='code'
  alias c.='code .'
  alias cs="code --password-store=gnome-libsecret"
  alias fcode="flatpak run com.visualstudio.code --password-store=gnome-libsecret --enable-features=UseOzonePlatform --ozone-platform=wayland"
  alias dcode="XDG_CURRENT_DESKTOP=GNOME code" # distrobox code in kde
fi

if has_cmd pnpm; then
  alias n='pnpm'
  alias ni='pnpm install'
  alias ne='pnpm exec'
  alias nd='pnpm dev'
  alias nt='pnpm types'
  alias nc='pnpm ci'
  alias ntt='pnpm test'
fi

sup() {
  if is_ubuntu; then
    sudo apt-get -qq update && sudo apt-get -qq -y upgrade
  elif is_atomic; then
    sudo rpm-ostree upgrade
  elif is_rh; then
    sudo dnf update -q -y && sudo dnf upgrade -q -y
  elif is_tw; then
    sudo zypper refresh && sudo zypper --non-interactive --quiet dup
  elif is_mac; then
    brew update && brew upgrade
  elif is_arch; then
    sudo pacman -Syu --noconfirm --quiet
  else
    echo "Unknown OS. Cannot upgrade."
  fi
}

if is_ubuntu; then
  alias osi="sudo apt-get -qq -y install"
  alias oss="apt-cache search"
  alias osr="sudo apt-get purge"
elif is_rh; then
  alias osi="sudo dnf -q -y install"
  alias oss="dnf search"
  alias osr="sudo dnf remove"
elif is_tw; then
  alias osi="sudo zypper --non-interactive --quiet install --auto-agree-with-licenses"
  alias oss="zypper search"
  alias osr="sudo zypper remove"
elif is_mac; then
  alias osi="brew install -q"
  alias oss="brew search"
  alias osr="brew uninstall"
elif is_arch; then
  alias osi="sudo pacman -S --needed --quiet --noconfirm"
  alias oss="pacman -Ss"
  alias osr="sudo pacman -R"
elif is_alpine; then
  alias osi="sudo apk add --no-cache"
  alias oss="apk search"
  alias osr="sudo apk del"
elif is_nixos; then
  alias oss="nix search nixpkgs"
  alias osi="nix profile install"
  alias osr="nix profile remove"

  nix-update-wsl() {
    local profile="${1:-wsl}"
    if dir_exists ~/nixos-config; then
      nix flake update ~/nixos-config
      sudo nixos-rebuild switch --flake ~/nixos-config\#"${profile}"
    elif dir_exists "$DOT_DIR/extras/home-manager"; then
      nix flake update "$DOT_DIR/extras/home-manager"
      sudo nixos-rebuild switch --flake ~/nixos-config\#"${profile}"
    else
      fail "Cannot find config ~/nixos-config or $DOT_DIR/extras/home-manager"
      return 1
    fi
  }

  nix-update-mac() {
    local profile="${1:-mac}"
    if dir_exists ~/darwin-config; then
      nix flake update ~/darwin-config
      sudo darwin-rebuild switch --flake ~/darwin-config\#"${profile}"
    elif dir_exists "$DOT_DIR/extras/home-manager"; then
      nix flake update "$DOT_DIR/extras/home-manager"
      sudo darwin-rebuild switch --flake ~/darwin-config\#"${profile}"
    else
      fail "Cannot find config ~/darwin-config or $DOT_DIR/extras/home-manager"
      return 1
    fi
  }
fi

if has_cmd git; then
  alias git-unstage="git reset HEAD"
  alias git-discard="git checkout --"
  alias gst="git status"
  alias gsu="git status -u"
  alias tsgfm="git stash && ((git pull --rebase || git pull); git stash pop)"

  alias gun="git-unstage"
  alias gur="git-discard"
  alias gcm="git commit -m"
  alias gcne="git commit --no-edit"
  alias gca="git commit --amend"
  alias gcan="git commit --amend --no-edit"

  alias Gcm="git commit --no-verify -m"
  alias Gp="gp --no-verify"
  alias Gcan="gcan --no-verify"

  alias g='git'
  alias gs="git stash -u"
  alias gst="git status"
  alias gsu="git status -u"
  alias gcan="git commit --amend --no-edit"
  alias gsa='git stash apply'
  alias gfm='git pull'
  alias gp='git push'
  alias gcm='git commit --message'
  alias gia='git add'
  alias gl='git log --topo-order --pretty=format:"%C(yellow)%h%C(reset)%C(black)%d%C(reset) %C(cyan)%ar%C(reset) %C(green)%an%C(reset)%n%C(white)%s%C(reset)"'
  alias gco='git checkout'
  alias gb='git branch'
  alias gbc='git checkout -b'
  alias gbc='git checkout -b'
  alias gsl='git stash list'
  gpp() {
    safe_push "$@"
  }
  alias clone='gh repo clone'
  alias glog="git log --graph --topo-order --pretty='%w(100,0,6)%C(yellow)%h%C(bold)%C(black)%d %C(cyan)%ar %C(green)%an%n%C(bold)%C(white)%s %N' --abbrev-commit"
fi

has_cmd nmap && alias nm="nmap -sC -sV -oN"

has_cmd nvim && alias v="nvim"
has_cmd code && alias c="code"
has_cmd tmux && alias t="tmux"

if has_cmd docker; then
  alias d="docker"
  alias dco="docker compose"
  alias dps="docker ps"
  alias dpa="docker ps -a"
  alias dl="docker ps -l -q"
  alias dx="docker exec -it"
  alias dlogs="docker logs -f"
  alias lzg='lazygit'
  alias lzd='lazydocker'
fi

if has_cmd distrobox; then
  alias db='distrobox'
  alias dbe='distrobox enter -nw --clean-path'
  alias dbl='distrobox list'
  alias dbr='distrobox run'
  alias dbc='distrobox create'
  alias dbs='distrobox stop'
  alias dbu='distrobox upgrade'
  alias dbrm='distrobox rm'

  dbrc() {
    if [ -z "$2" ]; then
      echo "Usage: dbrc <container_name> <command>"
      return 1
    fi
    local container="$1"
    shift
    distrobox run --name "$container" -- "$@"
  }

  dbsa() {
    local containers
    containers=$(distrobox list --no-color | awk 'NR>1 && $3 == "Up" {print $2}')
    for container in $containers; do
      echo "Stopping $container..."
      distrobox stop "$container"
    done
  }

  # List containers with details
  dbld() {
    distrobox list --no-color | column -t -s '|'
  }

  # Export app from container to host
  dbexp() {
    if [ -z "$2" ]; then
      echo "Usage: dbexp <container_name> <app_command>"
      return 1
    fi
    distrobox export --name "$1" --app "$2" --export-path "$HOME/.local/bin"
  }

  # Import app from host to container
  dbimp() {
    if [ -z "$2" ]; then
      echo "Usage: dbimp <container_name> <app_command>"
      return 1
    fi
    distrobox enter --name "$1" -- distrobox-export --app "$2" --export-path "$HOME/.local/bin"
  }

  dbsh() {
    local shell="${2:-bash}"
    if [ -z "$1" ]; then
      echo "Usage: dbsh <container_name> [shell]"
      return 1
    fi
    distrobox enter --name "$1" --additional-flags "--shell $shell"
  }

  dbmount() {
    if [ -z "$3" ]; then
      echo "Usage: dbmount <container_name> <host_path> <container_path>"
      return 1
    fi
    distrobox enter --name "$1" --additional-flags "--volume $2:$3"
  }

  dbbackup() {
    if [ -z "$1" ]; then
      echo "Usage: dbbackup <container_name>"
      return 1
    fi
    local backup_dir="${BOXES_DIR:-$HOME/.local/share/distrobox}/backups"
    mkdir -p "$backup_dir"
    echo "Backing up $1 to $backup_dir/$1.tar.gz"
    distrobox stop "$1" 2>/dev/null
    cd "${BOXES_DIR:-$HOME/.local/share/distrobox}" && tar -czf "$backup_dir/$1.tar.gz" "$1"
  }

  dbrestore() {
    if [ -z "$1" ]; then
      echo "Usage: dbrestore <container_name>"
      return 1
    fi
    local backup_dir="${BOXES_DIR:-$HOME/.local/share/distrobox}/backups"
    if [ -f "$backup_dir/$1.tar.gz" ]; then
      cd "${BOXES_DIR:-$HOME/.local/share/distrobox}" && tar -xzf "$backup_dir/$1.tar.gz"
      echo "Restored $1 from backup"
    else
      echo "Backup not found: $backup_dir/$1.tar.gz"
      return 1
    fi
  }

  dbd() {
    distrobox list | grep -q "$1" || return
    distrobox rm "$@" && srm "${BOXES_DIR}/$1"
  }

  alias rdbe='distrobox enter -nw --clean-path --root'
  alias rdbl='distrobox list --root'
  alias rdbr='distrobox run --root'
  alias rdbc='distrobox create --root'
  alias rdbs='distrobox stop --root'
  alias rdbu='distrobox upgrade --root'
  alias rdbrm='distrobox rm --root'

  rdbd() {
    distrobox list --root | grep -q "$1" || return
    distrobox rm --root "$@" && srm "${BOXES_DIR}/$1"
  }

  # Host integration aliases
  [[ "${CONTAINER_ID}" != "" ]] && alias on-host='distrobox-host-exec'
  [[ "${CONTAINER_ID}" != "" ]] && alias host-cmd='distrobox-host-exec'
fi

if has_cmd fastfetch; then
  alias sys-info='fastfetch'
elif has_cmd neofetch; then
  alias sys-info='neofetch'
fi

if has_cmd toolbox; then
  alias tbox='toolbox'
  alias tboxe='toolbox enter'
  alias tboxl='toolbox list'
  alias tboxr='toolbox run'
  alias tboxc='toolbox create'
fi

alias la=tree
alias lm='la | "$PAGER"' # Lists human readable sizes, hidden files through pager.
alias lr='ll -R'         # Lists human readable sizes, recursively.
alias lc='lt -c'         # Lists sorted by date, most recent last, shows change time.
alias lu='lt -u'         # Lists sorted by date, most recent last, shows access time.
alias sl='ls'            # Correction for common spelling error.

alias md="mkdir -p"
alias rd="rmdir"
alias cpr="cp -r"
alias rd="rmdir"
alias del="trash"
alias ipa="ip -brief a"

has_cmd gdu || has_cmd gdu-go && alias gdu="gdu-go"

alias ..="../"
alias ...="../../"
alias ....="../../../"
alias .....="../../../../"
alias ......="../../../../../"

if has_cmd flatpak; then
  alias fps="flatpak search"
  alias fpr="flatpak run"
fi

if [[ -d "$HOME/.local/share/pnpm" ]]; then
  alias n='pnpm'
  alias ni='pnpm install'
  alias nid='pnpm install -D'
  alias nb='pnpm build'
  alias nl='pnpm lint:dev'
  alias ne='pnpm exec'
  alias nd='pnpm dev'
  alias nc='pnpm ci'
  alias nt='pnpm types:dev'
  alias ntc='pnpm types'
  alias ntt='pnpm test:dev'
  alias nttc='pnpm test:dev'
  alias nci='pnpm types && pnpm lint'
  alias ndb='pnpm db'
  alias ndbt='pnpm db:types'
  alias ndbp='pnpm db:push'
  alias ndbs='pnpm db:seed'
  alias ndbst='pnpm db:studio'
  alias ndbr='pnpm db:repl'
fi

if has_cmd eza; then
  alias ls="eza -a --icons=auto --group-directories-first"
  alias ll='eza -l --icons=auto --group-directories-first'
  alias l1='eza -1'
  alias l="eza -l --icons --git -a"
  alias lt="eza --tree --level=2 --long --icons --git"
  alias ltree="eza --tree --level=2  --icons --git"
  # alias ls='eza -lh --group-directories-first --icons'

  alias lt='eza --tree --level=2 --long --icons --git'
  alias l.='eza -d .*'
else
  alias l='ls -1A'  # Lists in one column, hidden files.
  alias ll='ls -lh' # Lists human readable sizes.
  alias lk='ll -Sr' # Lists sorted by size, largest last.
  alias lt='ll -tr' # Lists sorted by date, most recent last.
fi

# ugrep for grep
if has_cmd ug; then
  alias fgrep='ug -F'
  alias xzgrep='ug -z'
  alias xzegrep='ug -zE'
  alias xzfgrep='ug -zF'
fi

if has_cmd lazyvim && has_cmd nvim; then
  alias lv="NVIM_APPNAME=lazyvim nvim"
fi

alias lsa='ls -a'
alias lta='lt -a'

if has_cmd fzf; then
  alias ff="fzf --preview 'bat --style=numbers --color=always {}'"
  alias fv="fzf --bind 'enter:become(vim {})'"
fi

fcd() {
  cd "$(find . -type d -not -path '*/.*' | fzf)" && l
}

fvim() {
  local file
  file=$(find . -type f -not -path '*/.*' | fzf)
  if [ -n "$file" ]; then
    nvim "$file"
  fi
}

if has_cmd emacs; then
  # export EDITOR="emacsclient -t"
  # export VISUAL="emacsclient -c -n"
  alias e="emacsclient -t"
  alias ec="emacsclient -c -n"
  alias en="emacs -nw"
fi

if has_cmd bat; then
  alias cat="bat"
elif has_cmd batcat; then
  alias bat="batcat"
  alias cat="batcat"
fi

if has_cmd virsh; then
  alias vmsy="virsh --connect qemu:///system"
  alias vmse="virsh --connect qemu:///session"

  alias vl="virsh list --all"
  alias vs="virsh start"
  alias vsh="virsh shutdown"
  alias vd="virsh destroy"
  alias vu="virsh undefine 2> /dev/null || virsh undefine --nvram"
  alias vv="virt-viewer"
fi

if has_cmd virt-install; then
  alias vmsyc="virt-install --connect qemu:///system"
  alias vmse="virt-install --connect qemu:///session"
fi

if has_cmd nixos-rebuild; then
  alias nrf="sudo nixos-rebuild switch --flake"
  alias nrb="sudo nixos-rebuild build --flake"
  alias nrb-vm="sudo nixos-rebuild build-vm -I nixos-config="
fi

if has_cmd nixos-generate; then
  alias ng-vm="nixos-generate -f vm -c"
  alias ng-iso="nixos-generate -f install-iso -c"
  alias ng-pvm="nixos-generate -f proxmox -c"
  alias ng-pmox="nixos-generate -f proxmox -c"
fi

has_cmd home-manager && alias hmf="home-manager switch --impure -b bak --flake"

if has_cmd zoxide && has_cmd z; then
  alias cd="z"
fi

if ! has_cmd nix && has_cmd nix-portable; then
  alias nix-shell="nix-portable nix-shell"
  alias nix-dev="nix-portable nix develop"
fi

quiet-echo() {
  if [[ "$1" == "--quiet" ]]; then
    local _quiet=1
    shift
  fi

  if [[ -z "$_quiet" ]]; then
    echo "$@"
  fi
}

flatpak-alias() {
  if [[ "$1" == "--quiet" ]]; then
    local _quiet=1
    shift
  fi

  local cmd="$1"
  local flatpak_id="$2"

  if [[ -z "$cmd" ]]; then
    [[ -z "$_quiet" ]] && echo "❌ Command name is required" >&2
    return 2
  fi

  if [[ -z "$flatpak_id" ]]; then
    [[ -z "$_quiet" ]] && echo "❌ Flatpak ID is required" >&2
    return 3
  fi

  if ! has_cmd flatpak; then
    [[ -z "$_quiet" ]] && echo "❌ flatpak command not found" >&2
    return 4
  fi

  if has_cmd "$cmd"; then
    [[ -z "$_quiet" ]] && echo "⚠️ $cmd already exists, skipping flatpak alias creation" >&2
    return 5
  fi

  if [[ -z "${FLATPAK_LIST:-}" ]]; then
    if ! FLATPAK_LIST=$(flatpak list --columns=application 2>/dev/null); then
      [[ -z "$_quiet" ]] && echo "❌ Failed to retrieve flatpak application list" >&2
      return 6
    fi
  fi

  if printf '%s\n' "$FLATPAK_LIST" | grep -Fxq -- "$flatpak_id"; then
    [[ -z "$_quiet" ]] && echo "✨ Creating alias for $cmd -> flatpak run $flatpak_id"
    local alias_def
    printf -v alias_def "%s=%s" "$cmd" "flatpak run $flatpak_id"
    if ! alias "$alias_def"; then
      [[ -z "$_quiet" ]] && echo "❌ Failed to create alias for $cmd" >&2
      return 7
    fi
    return 0
  else
    [[ -z "$_quiet" ]] && echo "⚠️ Flatpak app '$flatpak_id' not installed, skipping alias creation for $cmd" >&2
    return 8
  fi
}

flatpak-aliases-create() {
  # --quiet
  if [[ "$1" == "--quiet" ]]; then
    local _quiet=1
  fi

  if [[ -v CONTAINER_ID ]]; then
    [[ -z "$_quiet" ]] && echo "📦 In a container environment, skipping flatpak alias creation"
    return 0
  fi

  if ! has_cmd flatpak; then
    [[ -z "$_quiet" ]] && echo "📦 flatpak not installed, skipping flatpak alias creation"
    return 1
  fi

  if ! FLATPAK_LIST=$(flatpak list --columns=application 2>/dev/null); then
    [[ -z "$_quiet" ]] && echo "❌ Failed to retrieve flatpak application list"
    return 2
  fi

  local aliases=(
    "wezterm:org.wezfurlong.wezterm"
    "clion:com.jetbrains.CLion"
    "chrome:com.google.Chrome"
    "code:com.visualstudio.code"
    "nvim:io.neovim.nvim"
    "emacs:org.gnu.emacs"
  )

  local failed_aliases=()

  for alias_def in "${aliases[@]}"; do
    IFS=':' read -r cmd flatpak_id <<<"$alias_def"
    if ! flatpak-alias --quiet "$cmd" "$flatpak_id"; then
      failed_aliases+=("$cmd")
    fi
  done

  if [[ ${#failed_aliases[@]} -gt 0 ]]; then
    [[ -z "$_quiet" ]] && echo "❌ Failed to create aliases for: ${failed_aliases[*]}"
  fi

  unset FLATPAK_LIST
}

flatpak-aliases-create --quiet
