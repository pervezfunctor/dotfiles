#!/usr/bin/env bash

# shellcheck disable=SC2120
# shellcheck disable=SC1091

font-names() {
  if ! has_cmd fc-list; then
    warn "fc-list not installed, cannot list fonts"
    return 1
  fi

  fc-list : family | cut -d: -f2 | sed 's/^ //g' | sort | uniq
}

git-checkout-previous-file() {
  if ! has_cmd git; then
    warn "git not installed, cannot checkout previous file version"
    return 1
  fi

  if [ -z "$1" ]; then
    echo "Usage: git-checkout-previous-file <file>"
    return 1
  fi
  local file="$1"
  local prev_commit
  prev_commit=$(git log --format=%H -- "$file" | sed -n '2p')
  if [ -z "$prev_commit" ]; then
    echo "No previous commit found for $file"
    return 1
  fi
  git checkout "$prev_commit" -- "$file"
}

osquery-update-db() {
  if ! has_cmd osinfo-db-import; then
    warn "osinfo-db-import not installed, cannot update osquery database"
    return 1
  fi

  sudo osinfo-db-import --system --latest
}

function safe_push() {
  git stash -u && git push "$@" && git stash pop
}

one-shell-tmux() {
  local tmux_session="default"

  [[ -n "$TMUX" || -n "$EMACS" || -n "$INSIDE_EMACS" || -n "$VIM" || -n "$VSCODE_RESOLVING_ENVIRONMENT" || "$TERM_PROGRAM" == "vscode" ]] && return

  tmux start-server

  if ! tmux has-session -t "$tmux_session" 2>/dev/null; then
    tmux new-session -d -s "$tmux_session"
  fi

  exec tmux attach-session -t "$tmux_session"
}

nvim-update() {
  if has_cmd nvim; then
    nvim --headless "+Lazy! sync" +qa
  else
    warn "nvim not available, skipping nvim extensions update."
  fi
}

system-update() {
  if has_cmd sup; then
    sup
  fi

  if has_cmd flatpak; then
    flatpak update --user -y
    flatpak update -y
  fi

  has_cmd snap && snap refresh
  has_cmd brew && brew upgrade
  has_cmd mise && mise self-update && mise upgrade --bump
  has_cmd pixi && pixi global update

  cd "$DOT_DIR" && git-up
  has_cmd devbox && devbox update
}

remove_keyrings() {
  sudo rm -rf /run/user/1000/keyrings/*
  trash .local/share/keyrings/*
}

partitions() {
  lsblk -f -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,UUID | grep -v '/snap/'
  echo "Total block devices (excluding snaps): $(lsblk -f | grep -v '/snap/' | grep -c '^[a-z]')"

}

subvolumes() {
  local btrfs_mounts
  btrfs_mounts=$(mount | grep "type btrfs" | awk '{print $3}' | sort -u)

  if [ -z "$btrfs_mounts" ]; then
    echo "No Btrfs filesystems found."
    return 1
  fi

  for mount_point in $btrfs_mounts; do
    echo "Btrfs filesystem: $mount_point"
    echo "----------------------------------------"
    if ! sudo btrfs subvolume list -p -t "$mount_point" 2>/dev/null; then
      echo "Unable to list subvolumes for $mount_point"
    fi
  done

  echo
  echo "Btrfs filesystems: $(echo "$btrfs_mounts" | wc -l)"
}

sync-folders() {
  if ! has_cmd rsync; then
    warn "rsync not installed, skipping sync"
    return 1
  fi

  local delete_flag=""
  local dry_flag=""

  [[ "$1" == "--delete" ]] && {
    delete_flag="--delete"
    shift
  }
  [[ "$1" == "--dry-run" ]] && {
    dry_flag="--dry-run"
    shift
  }

  if [[ $# -ne 2 ]]; then
    fail "Usage: sync-folders [--delete] [--dry-run] <source> <destination>"
    return 1
  fi

  local source="$1"
  local destination="$2"

  if [[ ! -d "$source" ]]; then
    fail "Source directory $source does not exist"
    return 1
  fi

  if [[ ! -d "$destination" ]]; then
    fail "Destination directory $destination does not exist"
    return 1
  fi

  slog "Syncing $source to $destination"
  rsync -avh $delete_flag $dry_flag "$source/" "$destination/" || return $?
}

syslogs() {
  sudo journalctl -b -p 3 -xn
}

source "${DOT_DIR}/share/dbox-fns"
source "${DOT_DIR}/share/tbox-fns"
source "${DOT_DIR}/share/incus-fns"
source "${DOT_DIR}/share/virt-fns"

commands_available() {
  local failed=()
  for cmd in "$@"; do
    has_cmd "$cmd" || {
      failed+=("$cmd")
    }
  done

  if ((${#failed[@]})); then
    fail "Missing required commands: ${failed[*]}"
    return 1
  fi

  return 0
}

check_commands() {
  commands_available "$@" || die "Missing required commands, quitting"
}

dirs_available() {
  local failed=()
  for dir in "$@"; do
    dir_exists "$dir" || {
      failed+=("$dir")
    }
  done

  if ((${#failed[@]})); then
    fail "Missing required directories: ${failed[*]}"
    return 1
  fi

  return 0
}

check_dirs() {
  dirs_available "$@" || die "Missing required directories, quitting"
}

create-ublue-nix-mount() {
  local subvol_path="${1:-/home/@nix}"
  local mount_point="${2:-/nix}"
  local parent_dir

  parent_dir=$(dirname "$subvol_path")

  commands_available findmnt btrfs systemd-escape systemctl || return 1
  dirs_available "$parent_dir" "$mount_point" || return 1

  local parent_fstype
  parent_fstype=$(findmnt -nro FSTYPE "$parent_dir") || {
    fail "cannot determine filesystem for $parent_dir"
    return 1
  }

  [[ $parent_fstype == btrfs ]] || {
    fail "$parent_dir is not on a Btrfs filesystem"
    return 1
  }

  local device
  device=$(findmnt -nro SOURCE "$parent_dir") || {
    fail "cannot resolve backing device for $parent_dir"
    return 1
  }

  [[ -n $device ]] || {
    fail "empty device name for $parent_dir"
    return 1
  }

  if ! sudo btrfs subvolume show "$subvol_path" >/dev/null 2>&1; then
    if sudo test -e "$subvol_path"; then
      fail "$subvol_path exists but is not a Btrfs subvolume"
      return 1
    fi
    sudo btrfs subvolume create "$subvol_path" >/dev/null || {
      fail "failed to create subvolume at $subvol_path"
      return 1
    }
  fi

  local subvol_id
  subvol_id=$(sudo btrfs subvolume show "$subvol_path" | awk -F': ' '/Subvolume ID/{print $2; exit}')
  [[ -n $subvol_id ]] || {
    fail "unable to read subvolume ID for $subvol_path"
    return 1
  }

  local mount_active=0

  if findmnt -rn --target "$mount_point" >/dev/null 2>&1; then
    local current_device current_options current_subvolid
    current_device=$(findmnt -rn -o SOURCE "$mount_point")
    current_options=$(findmnt -rn -o OPTIONS "$mount_point")
    current_subvolid=$(printf '%s\n' "$current_options" | tr ',' '\n' | awk -F= '$1=="subvolid"{print $2}')

    if [[ $current_device == "$device" && $current_subvolid == "$subvol_id" ]]; then
      mount_active=1
    else
      fail "$mount_point already mounted (device=$current_device subvolid=${current_subvolid:-unknown}); refusing to change it"
      return 1
    fi
  else
    sudo mount -t btrfs -o "subvolid=$subvol_id" "$device" "$mount_point" || {
      fail "failed to mount $device (subvolid=$subvol_id) at $mount_point"
      return 1
    }
    mount_active=1
  fi

  [[ $mount_active -eq 1 ]] || {
    fail "unable to verify mount state for $mount_point"
    return 1
  }

  local unit_name
  unit_name=$(systemd-escape --path --suffix=mount "$mount_point") || {
    fail "failed to derive systemd unit name for $mount_point"
    return 1
  }

  local unit_path="/etc/systemd/system/$unit_name"
  local what_source="$device"

  if [[ $what_source != UUID=* ]]; then
    if has_cmd blkid; then
      local uuid
      uuid=$(sudo blkid -s UUID -o value "$device" 2>/dev/null)
      if [[ -n $uuid ]]; then
        what_source="UUID=$uuid"
      fi
    fi
  fi

  local mount_options="subvolid=$subvol_id"
  local unit_description="Mount $mount_point (subvolid $subvol_id)"
  local unit_content
  printf -v unit_content '%s\n' \
    "[Unit]" \
    "Description=$unit_description" \
    "After=local-fs.target" \
    "" \
    "[Mount]" \
    "What=$what_source" \
    "Where=$mount_point" \
    "Type=btrfs" \
    "Options=$mount_options" \
    "" \
    "[Install]" \
    "WantedBy=local-fs.target"

  local tmp_unit
  tmp_unit=$(mktemp) || {
    fail "failed to create temporary file for $unit_name"
    return 1
  }

  printf '%s\n' "$unit_content" >"$tmp_unit" || {
    rm -f "$tmp_unit"
    fail "failed to prepare unit content for $unit_name"
    return 1
  }

  sudo install -m 0644 -D "$tmp_unit" "$unit_path" || {
    rm -f "$tmp_unit"
    fail "failed to write $unit_path"
    return 1
  }

  rm -f "$tmp_unit"

  sudo systemctl daemon-reload || {
    fail "systemctl daemon-reload failed"
    return 1
  }

  sudo systemctl enable --now "$unit_name" >/dev/null 2>&1 || {
    fail "failed to enable $unit_name"
    return 1
  }

  return 0
}

fzf-select() {
  local prompt
  prompt=${1:-"Select > "}
  shift 2>/dev/null || true

  if ! command -v fzf >/dev/null 2>&1; then
    return 127
  fi

  if [ -t 0 ]; then
    # No piped input; use provided args
    if [ "$#" -eq 0 ]; then
      return 1
    fi
    printf '%s\n' "$@" | fzf --prompt="$prompt" --height=40% --reverse
  else
    # Use piped stdin
    fzf --prompt="$prompt" --height=40% --reverse
  fi
}

vme-ssh() {
  if ! has_cmd vme; then
    fail "vme command not found in PATH"
    return 1
  fi

  local vms
  if ! vms=$(vme list 2>/dev/null | awk 'NR>2 && $0 !~ /^[-[:space:]]*$/ {print $2}'); then
    fail "failed to list virtual machines"
    return 1
  fi

  if [[ -z "$vms" ]]; then
    warn "no virtual machines found"
    return 1
  fi

  local selected rc
  selected=$(printf '%s\n' "$vms" | fzf-select 'VM > ')
  rc=$?
  if [[ $rc -ne 0 || -z "$selected" ]]; then
    if [[ $rc -eq 127 ]]; then
      fail "fzf is not installed or not in PATH"
    else
      warn "selection cancelled"
    fi
    return 1
  fi

  if ! vme ssh "$selected"; then
    fail "ssh to '$selected' failed"
    return 1
  fi

  return 0
}
