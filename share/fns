#!/usr/bin/env bash

# shellcheck disable=SC2120
# shellcheck disable=SC1091

font-names() {
  if ! has_cmd fc-list; then
    warn "fc-list not installed, cannot list fonts"
    return 1
  fi

  fc-list : family | cut -d: -f2 | sed 's/^ //g' | sort | uniq
}

git-checkout-previous-file() {
  if ! has_cmd git; then
    warn "git not installed, cannot checkout previous file version"
    return 1
  fi

  if [ -z "$1" ]; then
    echo "Usage: git-checkout-previous-file <file>"
    return 1
  fi
  local file="$1"
  local prev_commit
  prev_commit=$(git log --format=%H -- "$file" | sed -n '2p')
  if [ -z "$prev_commit" ]; then
    echo "No previous commit found for $file"
    return 1
  fi
  git checkout "$prev_commit" -- "$file"
}

osquery-update-db() {
  if ! has_cmd osqueryi; then
    warn "osqueryi not installed, cannot update osquery database"
    return 1
  fi

  sudo osinfo-db-import --system --latest
}

function safe_push() {
  git stash -u && git push "$@" && git stash pop
}

one-shell-tmux() {
  local tmux_session="default"

  [[ -n "$TMUX" || -n "$EMACS" || -n "$INSIDE_EMACS" || -n "$VIM" || -n "$VSCODE_RESOLVING_ENVIRONMENT" || "$TERM_PROGRAM" == "vscode" ]] && return

  tmux start-server

  if ! tmux has-session -t "$tmux_session" 2>/dev/null; then
    tmux new-session -d -s "$tmux_session"
  fi

  exec tmux attach-session -t "$tmux_session"
}

nvim-update() {
  if has_cmd nvim; then
    nvim --headless "+Lazy! sync" +qa
  else
    warn "nvim not available, skipping nvim extensions update."
  fi
}

system-update() {
  if has_cmd sup; then
    sup
  fi

  if has_cmd flatpak; then
    flatpak update --user -y
    flatpak update -y
  fi

  has_cmd snap && snap refresh
  has_cmd brew && brew upgrade
  has_cmd mise && mise self-update && mise upgrade --bump
  has_cmd pixi && pixi global update

  cd "$DOT_DIR" && git-up
  has_cmd devbox && devbox update
}

remove_keyrings() {
  sudo rm -rf /run/user/1000/keyrings/*
  trash .local/share/keyrings/*
}

partitions() {
  lsblk -f -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,UUID | grep -v '/snap/'
  echo "Total block devices (excluding snaps): $(lsblk -f | grep -v '/snap/' | grep -c '^[a-z]')"

}

subvolumes() {
  local btrfs_mounts
  btrfs_mounts=$(mount | grep "type btrfs" | awk '{print $3}' | sort -u)

  if [ -z "$btrfs_mounts" ]; then
    echo "No Btrfs filesystems found."
    return 1
  fi

  for mount_point in $btrfs_mounts; do
    echo "Btrfs filesystem: $mount_point"
    echo "----------------------------------------"
    if ! sudo btrfs subvolume list -p -t "$mount_point" 2>/dev/null; then
      echo "Unable to list subvolumes for $mount_point"
    fi
  done

  echo
  echo "Btrfs filesystems: $(echo "$btrfs_mounts" | wc -l)"
}

sync-folders() {
  if ! has_cmd rsync; then
    warn "rsync not installed, skipping sync"
    return 1
  fi

  local delete_flag=""
  local dry_flag=""

  [[ "$1" == "--delete" ]] && {
    delete_flag="--delete"
    shift
  }
  [[ "$1" == "--dry-run" ]] && {
    dry_flag="--dry-run"
    shift
  }

  if [[ $# -ne 2 ]]; then
    fail "Usage: sync-folders [--delete] [--dry-run] <source> <destination>"
    return 1
  fi

  local source="$1"
  local destination="$2"

  if [[ ! -d "$source" ]]; then
    fail "Source directory $source does not exist"
    return 1
  fi

  if [[ ! -d "$destination" ]]; then
    fail "Destination directory $destination does not exist"
    return 1
  fi

  slog "Syncing $source to $destination"
  rsync -avh $delete_flag $dry_flag "$source/" "$destination/" || return $?
}

syslogs() {
  sudo journalctl -b -p 3 -xn
}

source "${DOT_DIR}/share/dbox-fns"
source "${DOT_DIR}/share/tbox-fns"
source "${DOT_DIR}/share/incus-fns"
source "${DOT_DIR}/share/virt-fns"
